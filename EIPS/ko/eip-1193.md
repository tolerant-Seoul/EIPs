---
eip: 1193
title: 이더리움 프로바이더 JavaScript API
description: 클라이언트와 애플리케이션 간의 일관성을 위한 JavaScript 이더리움 프로바이더 API
author: Fabian Vogelsteller (@frozeman), Ryan Ghods (@ryanio), Victor Maia (@MaiaVictor), Marc Garreau (@wolovim), Erik Marks (@rekmarks)
discussions-to: https://github.com/ethereum/EIPs/issues/2319
status: Final
type: Standards Track
category: Interface
created: 2018-06-30
requires: 155, 695
lang: ko
original: ../eip-1193.md
---

## 요약

클라이언트와 애플리케이션 간의 일관성을 위한 JavaScript 이더리움 프로바이더 API입니다.

## 개요

이더리움 웹 애플리케이션("dapp") 생태계에서 일반적인 관례는 키 관리 소프트웨어("지갑")가 웹 페이지의 JavaScript 객체를 통해 API를 노출하는 것입니다.
이 객체를 "프로바이더"라고 합니다.

역사적으로 프로바이더 구현은 지갑 간에 충돌하는 인터페이스와 동작을 보여왔습니다.
이 EIP는 지갑 상호 운용성을 촉진하기 위해 이더리움 프로바이더 API를 공식화합니다.
API는 최소화되고, 이벤트 기반이며, 전송 및 RPC 프로토콜에 무관하도록 설계되었습니다.
그 기능은 새로운 RPC 메서드와 `message` 이벤트 유형을 정의하여 쉽게 확장됩니다.

역사적으로 프로바이더는 웹 브라우저에서 `window.ethereum`으로 제공되어 왔지만, 이 관례는 사양의 일부가 아닙니다.

## 사양

이 문서에서 "반드시(MUST)", "반드시 아니다(MUST NOT)", "필수(REQUIRED)", "해야 한다(SHALL)", "해서는 안 된다(SHALL NOT)", "해야 한다(SHOULD)", "해서는 안 된다(SHOULD NOT)", "권장(RECOMMENDED)", "할 수 있다(MAY)", "선택적(OPTIONAL)"이라는 핵심 단어는 [RFC-2119](https://www.ietf.org/rfc/rfc2119.txt)에 설명된 대로 해석됩니다.

> 이와 같은 주석은 비규범적입니다.

### 정의

_이 섹션은 비규범적입니다._

- 프로바이더(Provider)
  - 소비자에게 제공되는 JavaScript 객체로, 클라이언트를 통해 이더리움에 대한 접근을 제공합니다.
- 클라이언트(Client)
  - 프로바이더로부터 원격 프로시저 호출(RPC) 요청을 수신하고 결과를 반환하는 엔드포인트입니다.
- 지갑(Wallet)
  - 개인 키를 관리하고, 서명 작업을 수행하며, 프로바이더와 클라이언트 사이의 미들웨어 역할을 하는 최종 사용자 애플리케이션입니다.
- 원격 프로시저 호출(RPC)
  - 원격 프로시저 호출(RPC)은 프로바이더, 지갑 또는 클라이언트에서 처리할 일부 절차에 대해 프로바이더에 제출되는 모든 요청입니다.

### 연결성

프로바이더가 최소 하나의 체인에 대한 RPC 요청을 처리할 수 있을 때 프로바이더가 "연결됨"이라고 합니다.

프로바이더가 어떤 체인에도 RPC 요청을 처리할 수 없을 때 프로바이더가 "연결 해제됨"이라고 합니다.

> RPC 요청을 처리하려면 프로바이더가 원격 위치에 요청을 성공적으로 제출하고 응답을 수신해야 합니다.
> 즉, 프로바이더가 네트워크 문제 등으로 인해 클라이언트와 통신할 수 없는 경우 프로바이더가 연결 해제됩니다.

### API

> 프로바이더 API는 TypeScript를 사용하여 지정됩니다.
> 작성자는 구현자가 이 섹션의 것을 기반으로 자신만의 유형과 인터페이스를 선언할 것을 권장합니다.
>
> 소비자 대상 API 문서는 [부록 I](#부록-i-소비자-대상-api-문서)를 참조하세요.

프로바이더는 이 섹션에 정의된 API를 **반드시** 구현하고 노출해야 합니다(MUST).
모든 API 엔티티는 이 섹션에 정의된 유형과 인터페이스를 **반드시** 준수해야 합니다(MUST).

#### request

> `request` 메서드는 원격 프로시저 호출(RPC)을 위한 전송 및 프로토콜에 무관한 래퍼 함수로 의도되었습니다.

```typescript
interface RequestArguments {
  readonly method: string;
  readonly params?: readonly unknown[] | object;
}

Provider.request(args: RequestArguments): Promise<unknown>;
```

프로바이더는 `RequestArguments.method`의 값으로 요청된 RPC 메서드를 **반드시** 식별해야 합니다(MUST).

요청된 RPC 메서드가 매개변수를 취하는 경우 프로바이더는 `RequestArguments.params`의 값으로 이를 **반드시** 수락해야 합니다(MUST).

RPC 요청은 반환된 Promise가 요청된 RPC 메서드의 사양에 따라 값으로 해결되거나 오류로 거부되도록 **반드시** 처리되어야 합니다(MUST).

해결되는 경우 Promise는 RPC 메서드의 사양에 따라 결과로 **반드시** 해결되어야 합니다(MUST). RPC 메서드의 반환 유형이 그렇게 정의되지 않는 한 Promise는 RPC 프로토콜별 응답 객체로 해결되어서는 **안 됩니다(MUST NOT)**.

반환된 Promise가 거부되는 경우 아래 [RPC 오류](#rpc-오류) 섹션에 지정된 `ProviderRpcError`로 **반드시** 거부해야 합니다(MUST).

반환된 Promise는 다음 조건 중 하나라도 충족되면 **반드시** 거부해야 합니다(MUST):

- RPC 요청에 대해 오류가 반환됩니다.
  - 반환된 오류가 `ProviderRpcError` 인터페이스와 호환되는 경우 Promise는 해당 오류로 직접 거부**할 수 있습니다(MAY)**.
- 프로바이더가 어떤 이유로든 오류를 만나거나 요청을 처리하지 못합니다.

> 프로바이더가 어떤 종류의 권한 부여 로직을 구현하는 경우 작성자는 권한 부여 실패 시 `4100` 오류로 거부할 것을 권장합니다.

반환된 Promise는 다음 조건 중 하나라도 충족되면 거부**해야 합니다(SHOULD)**:

- 프로바이더가 연결 해제되었습니다.
  - 이 이유로 거부하는 경우 Promise 거부 오류 `code`는 **반드시** `4900`이어야 합니다(MUST).
- RPC 요청이 특정 체인을 대상으로 하고, 프로바이더가 해당 체인에 연결되어 있지 않지만 최소 하나의 다른 체인에 연결되어 있습니다.
  - 이 이유로 거부하는 경우 Promise 거부 오류 `code`는 **반드시** `4901`이어야 합니다(MUST).

"연결됨" 및 "연결 해제됨"의 정의는 [연결성](#연결성) 섹션을 참조하세요.

### 지원되는 RPC 메서드

"지원되는 RPC 메서드"는 프로바이더를 통해 호출할 수 있는 모든 RPC 메서드입니다.

모든 지원되는 RPC 메서드는 고유한 문자열로 **반드시** 식별되어야 합니다(MUST).

프로바이더는 표준화되었든 아니든 목적을 달성하기 위해 필요한 모든 RPC 메서드를 지원**할 수 있습니다(MAY)**.

완료된 EIP에 정의된 RPC 메서드가 지원되지 않는 경우 아래 [프로바이더 오류](#프로바이더-오류) 섹션에 따라 `4200` 오류로 거부**해야 하거나(SHOULD)** RPC 메서드의 사양에 따라 적절한 오류로 거부해야 합니다.

#### RPC 오류

```typescript
interface ProviderRpcError extends Error {
  code: number;
  data?: unknown;
}
```

- `message`
  - 사람이 읽을 수 있는 문자열**이어야 합니다(MUST)**
  - 아래 [오류 표준](#오류-표준) 섹션의 사양을 준수**해야 합니다(SHOULD)**
- `code`
  - 정수**여야 합니다(MUST)**
  - 아래 [오류 표준](#오류-표준) 섹션의 사양을 준수**해야 합니다(SHOULD)**
- `data`
  - 오류에 대한 다른 유용한 정보를 포함**해야 합니다(SHOULD)**

##### 오류 표준

`ProviderRpcError` 코드와 메시지는 우선순위 순서대로 다음 규칙을 따라야 **합니다(SHOULD)**:

1. 아래 [프로바이더 오류](#프로바이더-오류) 섹션의 오류

2. 오류를 발생시키는 RPC 메서드의 사양에서 필수인 모든 오류

3. [`CloseEvent` 상태 코드](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes)

#### 프로바이더 오류

| 상태 코드 | 이름                  | 설명                                                              |
| ----------- | --------------------- | ------------------------------------------------------------------------ |
| 4001        | 사용자 요청 거부 | 사용자가 요청을 거부했습니다.                                           |
| 4100        | 권한 없음          | 요청된 메서드 및/또는 계정이 사용자에 의해 승인되지 않았습니다. |
| 4200        | 지원되지 않는 메서드    | 프로바이더가 요청된 메서드를 지원하지 않습니다.                      |
| 4900        | 연결 해제됨          | 프로바이더가 모든 체인에서 연결 해제되었습니다.                            |
| 4901        | 체인 연결 해제됨    | 프로바이더가 요청된 체인에 연결되어 있지 않습니다.                    |

> `4900`은 프로바이더가 모든 체인에서 연결 해제되었음을 나타내기 위한 것이고, `4901`은 프로바이더가 특정 체인에서만 연결 해제되었음을 나타내기 위한 것입니다.
> 즉, `4901`은 프로바이더가 다른 체인에 연결되어 있지만 요청된 체인에는 연결되어 있지 않음을 의미합니다.

### 이벤트

프로바이더는 다음 이벤트 처리 메서드를 **반드시** 구현해야 합니다(MUST):

- `on`
- `removeListener`

이러한 메서드는 Node.js [`EventEmitter` API](https://nodejs.org/api/events.html)에 따라 **반드시** 구현되어야 합니다(MUST).

> 이러한 요구 사항을 충족하려면 프로바이더 구현자는 단순히 Node.js `EventEmitter` 클래스를 확장하고 대상 환경에 맞게 번들링하는 것을 고려해야 합니다.

#### message

> `message` 이벤트는 다른 이벤트에서 다루지 않는 임의의 알림을 위한 것입니다.

발생할 때 `message` 이벤트는 다음 형식의 객체 인수와 함께 **반드시** 발생해야 합니다(MUST):

```typescript
interface ProviderMessage {
  readonly type: string;
  readonly data: unknown;
}
```

##### 구독

프로바이더가 이더리움 RPC 구독(예: [`eth_subscribe`](https://geth.ethereum.org/docs/rpc/pubsub))을 지원하는 경우 프로바이더는 구독 알림을 받을 때 `message` 이벤트를 **반드시** 발생시켜야 합니다(MUST).

프로바이더가 예를 들어 `eth_subscribe` 구독에서 구독 메시지를 받으면 프로바이더는 다음 형식의 `ProviderMessage` 객체와 함께 `message` 이벤트를 **반드시** 발생시켜야 합니다(MUST):

```typescript
interface EthSubscription extends ProviderMessage {
  readonly type: 'eth_subscription';
  readonly data: {
    readonly subscription: string;
    readonly result: unknown;
  };
}
```

#### connect

"연결됨"의 정의는 [연결성](#연결성) 섹션을 참조하세요.

프로바이더가 연결되면 프로바이더는 `connect`라는 이름의 이벤트를 **반드시** 발생시켜야 합니다(MUST).

여기에는 다음이 포함됩니다:

- 초기화 후 프로바이더가 처음으로 체인에 연결될 때.
- `disconnect` 이벤트가 발생한 후 프로바이더가 체인에 연결될 때.

이 이벤트는 다음 형식의 객체와 함께 **반드시** 발생해야 합니다(MUST):

```typescript
interface ProviderConnectInfo {
  readonly chainId: string;
}
```

`chainId`는 [`eth_chainId`](./eip-695.md) 이더리움 RPC 메서드에 따라 16진수 문자열로 연결된 체인의 정수 ID를 **반드시** 지정해야 합니다(MUST).

#### disconnect

"연결 해제됨"의 정의는 [연결성](#연결성) 섹션을 참조하세요.

프로바이더가 모든 체인에서 연결 해제되면 프로바이더는 [RPC 오류](#rpc-오류) 섹션에 정의된 인터페이스에 따라 값 `error: ProviderRpcError`와 함께 `disconnect`라는 이름의 이벤트를 **반드시** 발생시켜야 합니다(MUST). 오류의 `code` 속성 값은 [`CloseEvent`의 상태 코드](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes)를 **반드시** 따라야 합니다(MUST).

#### chainChanged

프로바이더가 연결된 체인이 변경되면 프로바이더는 [`eth_chainId`](./eip-695.md) 이더리움 RPC 메서드에 따라 16진수 문자열로 새 체인의 정수 ID를 지정하는 값 `chainId: string`과 함께 `chainChanged`라는 이름의 이벤트를 **반드시** 발생시켜야 합니다(MUST).

#### accountsChanged

프로바이더에서 사용 가능한 계정이 변경되면 프로바이더는 `eth_accounts` 이더리움 RPC 메서드에 따라 계정 주소를 포함하는 값 `accounts: string[]`과 함께 `accountsChanged`라는 이름의 이벤트를 **반드시** 발생시켜야 합니다(MUST).

"프로바이더에서 사용 가능한 계정"은 `eth_accounts`의 반환 값이 변경될 때 변경됩니다.

## 근거

프로바이더의 목적은 소비자에게 이더리움에 대한 접근을 _제공_하는 것입니다.
일반적으로 프로바이더는 이더리움 웹 애플리케이션이 두 가지를 할 수 있도록 해야 합니다:

- 이더리움 RPC 요청 수행
- 프로바이더의 이더리움 체인, 클라이언트 및 지갑의 상태 변경에 응답

프로바이더 API 사양은 단일 메서드와 5개의 이벤트로 구성됩니다.
`request` 메서드와 `message` 이벤트만으로도 완전한 프로바이더를 구현하기에 충분합니다.
이들은 각각 임의의 RPC 요청을 수행하고 임의의 메시지를 통신하도록 설계되었습니다.

나머지 4개의 이벤트는 두 가지 범주로 나눌 수 있습니다:

- RPC 요청을 수행하는 프로바이더 능력의 변경
  - `connect`
  - `disconnect`
- 모든 비사소한 애플리케이션이 처리해야 하는 일반적인 클라이언트 및/또는 지갑 상태 변경
  - `chainChanged`
  - `accountsChanged`

이러한 이벤트는 작성 시점에 관련 패턴의 광범위한 프로덕션 사용으로 인해 포함되었습니다.

## 하위 호환성

많은 프로바이더가 이 사양이 완료되기 전에 초안 버전을 채택했습니다.
현재 API는 레거시 버전의 엄격한 상위 집합이 되도록 설계되었으며, 이 사양은 그런 의미에서 완전히 하위 호환됩니다.
레거시 API는 [부록 III](#부록-iii-레거시-프로바이더-api)를 참조하세요.

이 사양만 구현하는 프로바이더는 레거시 API를 대상으로 하는 이더리움 웹 애플리케이션과 호환되지 않습니다.

## 구현

작성 시점에 다음 프로젝트에 작동하는 구현이 있습니다:

- [buidler.dev](https://github.com/nomiclabs/buidler/pull/608)
- [ethers.js](https://github.com/ethers-io/ethers.js/blob/56af4413b1dd1787db68985e0b612b63d86fdf7c/packages/providers/src.ts/web3-provider.ts)
- [eth-provider](https://www.npmjs.com/package/eth-provider)
- [MetaMask](https://github.com/MetaMask/inpage-provider)
- [WalletConnect](https://github.com/WalletConnect/walletconnect-monorepo/blob/d33fd2070d7a67f74de50fd10ca4217f4e2f22f3/packages/providers/web3-provider/README.md)
- [web3.js](https://web3js.readthedocs.io/)

## 보안 고려사항

프로바이더는 이더리움 클라이언트와 이더리움 애플리케이션 사이에 메시지를 전달하기 위한 것입니다.
개인 키나 계정 관리를 담당하지 _않습니다_. 단순히 RPC 메시지를 처리하고 이벤트를 발생시킵니다.
따라서 계정 보안과 사용자 개인 정보는 프로바이더와 이더리움 클라이언트 사이의 미들웨어에서 구현되어야 합니다.
실제로 이러한 미들웨어 애플리케이션을 "지갑"이라고 부르며, 일반적으로 사용자의 개인 키와 계정을 관리합니다.
프로바이더는 일부 제3자(예: 웹사이트)의 제어 하에 신뢰할 수 없는 환경에 노출된 지갑의 확장으로 생각할 수 있습니다.

### 적대적 행동 처리

JavaScript 객체이므로 소비자는 일반적으로 프로바이더에서 임의의 작업을 수행할 수 있으며 모든 속성을 읽거나 덮어쓸 수 있습니다.
따라서 프로바이더 객체를 적대자가 제어하는 것처럼 취급하는 것이 가장 좋습니다.
프로바이더 구현자가 다음을 보장하여 사용자, 지갑 및 클라이언트를 보호하는 것이 가장 중요합니다:

- 프로바이더에 개인 사용자 데이터가 포함되어 있지 않습니다.
- 프로바이더와 지갑 프로그램이 서로 격리되어 있습니다.
- 지갑 및/또는 클라이언트가 프로바이더의 요청을 속도 제한합니다.
- 지갑 및/또는 클라이언트가 프로바이더에서 보낸 모든 데이터의 유효성을 검사합니다.

### 체인 변경

모든 이더리움 작업은 특정 체인을 대상으로 하므로, `eth_chainId` 이더리움 RPC 메서드([EIP-695](./eip-695.md) 참조)에 따라 프로바이더가 클라이언트의 구성된 체인을 정확하게 반영하는 것이 중요합니다.

여기에는 `eth_chainId`가 올바른 반환 값을 갖도록 보장하고 해당 값이 변경될 때마다 `chainChanged` 이벤트가 발생하도록 보장하는 것이 포함됩니다.

### 사용자 계정 노출 및 계정 변경

많은 이더리움 쓰기 작업(예: `eth_sendTransaction`)은 사용자 계정을 지정해야 합니다.
프로바이더 소비자는 `eth_accounts` RPC 메서드를 통해 이러한 계정에 접근하고 `accountsChanged` 이벤트를 수신합니다.

`eth_chainId`와 마찬가지로 `eth_accounts`가 올바른 반환 값을 가지고 해당 값이 변경될 때마다 `accountsChanged` 이벤트가 발생하는 것이 중요합니다.

`eth_accounts`의 반환 값은 궁극적으로 지갑 또는 클라이언트에 의해 제어됩니다.
사용자 개인 정보를 보호하기 위해 작성자는 기본적으로 계정을 노출하지 않는 것을 권장합니다.
대신 프로바이더는 `eth_requestAccounts`([EIP-1102](./eip-1102.md) 참조) 또는 `wallet_requestPermissions`([EIP-2255](./eip-2255.md) 참조)와 같이 계정 접근을 명시적으로 요청하는 RPC 메서드를 지원해야 합니다.

## 참조

- [ethereum/interfaces의 초기 논의](https://github.com/ethereum/interfaces/issues/16)
- [폐지된 Ethereum Magicians 스레드](https://ethereum-magicians.org/t/eip-1193-ethereum-provider-javascript-api/640)
- [계속되는 논의](https://github.com/ethereum/EIPs/issues/2319)
- 관련 EIP
  - [EIP-1102: 옵트인 계정 노출](./eip-1102.md)
  - [EIP-1474: 원격 프로시저 호출 사양](./eip-1474.md)
  - [EIP-1767: 이더리움 노드 데이터에 대한 GraphQL 인터페이스](./eip-1767.md)
  - [EIP-2255: 지갑 권한](./eip-2255.md)

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.

## 부록 I: 소비자 대상 API 문서

### request

이더리움 RPC 메서드 호출을 수행합니다.

```typescript
interface RequestArguments {
  readonly method: string;
  readonly params?: readonly unknown[] | object;
}

Provider.request(args: RequestArguments): Promise<unknown>;
```

반환된 Promise는 메서드의 결과로 해결되거나 [`ProviderRpcError`](#오류)로 거부됩니다. 예를 들어:

```javascript
Provider.request({ method: 'eth_accounts' })
  .then((accounts) => console.log(accounts))
  .catch((error) => console.error(error));
```

각 이더리움 RPC 메서드의 `params` 및 반환 유형에 대해서는 해당 문서를 참조하세요.
일반적인 메서드 목록은 [여기](./eip-1474.md)에서 찾을 수 있습니다.

#### RPC 프로토콜

여러 RPC 프로토콜을 사용할 수 있습니다. 예를 들어:

- [EIP-1474](./eip-1474.md), 이더리움 JSON-RPC API
- [EIP-1767](./eip-1767.md), 이더리움 GraphQL 스키마

### 이벤트

이벤트는 Node.js [`EventEmitter` API](https://nodejs.org/api/events.html)의 규칙을 따릅니다.

#### connect

프로바이더는 다음과 같을 때 `connect`를 발생시킵니다:

- 초기화된 후 처음으로 체인에 연결될 때.
- `disconnect` 이벤트가 발생한 후 처음으로 체인에 연결될 때.

```typescript
interface ProviderConnectInfo {
  readonly chainId: string;
}

Provider.on('connect', listener: (connectInfo: ProviderConnectInfo) => void): Provider;
```

이벤트는 `eth_chainId` 이더리움 RPC 메서드에 따라 16진수 문자열 `chainId`와 프로바이더가 결정하는 기타 속성을 가진 객체를 발생시킵니다.

#### disconnect

프로바이더는 모든 체인에서 연결 해제될 때 `disconnect`를 발생시킵니다.

```typescript
Provider.on('disconnect', listener: (error: ProviderRpcError) => void): Provider;
```

이 이벤트는 [`ProviderRpcError`](#오류)를 발생시킵니다. 오류 `code`는 [`CloseEvent` 상태 코드](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes) 표를 따릅니다.

#### chainChanged

프로바이더는 새 체인에 연결할 때 `chainChanged`를 발생시킵니다.

```typescript
Provider.on('chainChanged', listener: (chainId: string) => void): Provider;
```

이벤트는 `eth_chainId` 이더리움 RPC 메서드에 따라 16진수 문자열 `chainId`를 발생시킵니다.

#### accountsChanged

프로바이더에서 반환된 계정(`eth_accounts`)이 변경되면 프로바이더는 `accountsChanged`를 발생시킵니다.

```typescript
Provider.on('accountsChanged', listener: (accounts: string[]) => void): Provider;
```

이벤트는 `eth_accounts` 이더리움 RPC 메서드에 따라 계정 주소 배열인 `accounts`와 함께 발생합니다.

#### message

프로바이더는 소비자에게 임의의 메시지를 통신하기 위해 `message`를 발생시킵니다.
메시지에는 JSON-RPC 알림, GraphQL 구독 및/또는 프로바이더가 정의한 기타 이벤트가 포함될 수 있습니다.

```typescript
interface ProviderMessage {
  readonly type: string;
  readonly data: unknown;
}

Provider.on('message', listener: (message: ProviderMessage) => void): Provider;
```

##### 구독

[`eth_` 구독 메서드](https://geth.ethereum.org/docs/rpc/pubsub) 및 [`shh_` 구독 메서드](https://github.com/ethereum/go-ethereum/wiki/Whisper-v6-RPC-API#shh_subscribe)는 구독 업데이트를 발생시키기 위해 이 이벤트에 의존합니다.

예를 들어 `eth_subscribe` 구독 업데이트의 경우 `ProviderMessage.type`은 문자열 `'eth_subscription'`과 같고 구독 데이터는 `ProviderMessage.data`의 값이 됩니다.

### 오류

```typescript
interface ProviderRpcError extends Error {
  message: string;
  code: number;
  data?: unknown;
}
```

## 부록 II: 예제

이 예제들은 웹 브라우저 환경을 가정합니다.

```javascript
// 대부분의 프로바이더는 페이지 로드 시 window.ethereum으로 사용 가능합니다.
// 이것은 관례일 뿐 표준이 아니며 실제로는 그렇지 않을 수 있습니다.
// 프로바이더 구현의 문서를 참조하세요.
const ethereum = window.ethereum;

// 예제 1: chainId 로그
ethereum
  .request({ method: 'eth_chainId' })
  .then((chainId) => {
    console.log(`16진수 문자열: ${chainId}`);
    console.log(`10진수: ${parseInt(chainId, 16)}`);
  })
  .catch((error) => {
    console.error(`chainId 가져오기 오류: ${error.code}: ${error.message}`);
  });

// 예제 2: 마지막 블록 로그
ethereum
  .request({
    method: 'eth_getBlockByNumber',
    params: ['latest', true],
  })
  .then((block) => {
    console.log(`블록 ${block.number}:`, block);
  })
  .catch((error) => {
    console.error(
      `마지막 블록 가져오기 오류: ${error.message}.
       코드: ${error.code}. 데이터: ${error.data}`
    );
  });

// 예제 3: 사용 가능한 계정 로그
ethereum
  .request({ method: 'eth_accounts' })
  .then((accounts) => {
    console.log(`계정:\n${accounts.join('\n')}`);
  })
  .catch((error) => {
    console.error(
      `계정 가져오기 오류: ${error.message}.
       코드: ${error.code}. 데이터: ${error.data}`
    );
  });

// 예제 4: 새 블록 로그
ethereum
  .request({
    method: 'eth_subscribe',
    params: ['newHeads'],
  })
  .then((subscriptionId) => {
    ethereum.on('message', (message) => {
      if (message.type === 'eth_subscription') {
        const { data } = message;
        if (data.subscription === subscriptionId) {
          if ('result' in data && typeof data.result === 'object') {
            const block = data.result;
            console.log(`새 블록 ${block.number}:`, block);
          } else {
            console.error(`문제 발생: ${data.result}`);
          }
        }
      }
    });
  })
  .catch((error) => {
    console.error(
      `newHeads 구독 생성 오류: ${error.message}.
       코드: ${error.code}. 데이터: ${error.data}`
    );
  });

// 예제 5: 계정 변경 시 로그
const logAccounts = (accounts) => {
  console.log(`계정:\n${accounts.join('\n')}`);
};
ethereum.on('accountsChanged', logAccounts);
// 구독 해제
ethereum.removeListener('accountsChanged', logAccounts);

// 예제 6: 연결 종료 시 로그
ethereum.on('disconnect', (code, reason) => {
  console.log(`이더리움 프로바이더 연결 종료: ${reason}. 코드: ${code}`);
});
```

## 부록 III: 레거시 프로바이더 API

이 섹션은 작성 시점에 프로덕션에서 광범위하게 사용되는 레거시 프로바이더 API를 문서화합니다.
완전히 표준화되지 않았으므로 실제로 상당한 편차가 발생합니다.
작성자는 레거시 이더리움 애플리케이션을 지원하기 위한 경우를 제외하고 구현하지 않을 것을 권장합니다.

### sendAsync (폐지됨)

이 메서드는 [`request`](#request)로 대체됩니다.

`sendAsync`는 `request`와 비슷하지만 JSON-RPC 객체와 콜백을 사용합니다.

```typescript
Provider.sendAsync(request: Object, callback: Function): void;
```

역사적으로 요청 및 응답 객체 인터페이스는 [이더리움 JSON-RPC 사양](./eip-1474.md)을 따랐습니다.

### send (폐지됨)

이 메서드는 [`request`](#request)로 대체됩니다.

```typescript
Provider.send(...args: unknown[]): unknown;
```

### 레거시 이벤트

#### close (폐지됨)

이 이벤트는 [`disconnect`](#disconnect)로 대체됩니다.

#### networkChanged (폐지됨)

이벤트 `networkChanged`는 [`chainChanged`](#chainchanged)로 대체됩니다.

자세한 내용은 [EIP-155: 간단한 재전송 공격 보호](./eip-155.md) 및 [EIP-695: JSON-RPC용 eth_chainId 메서드 생성](./eip-695.md)을 참조하세요.

#### notification (폐지됨)

이 이벤트는 [`message`](#message)로 대체됩니다.

역사적으로 이 이벤트는 예를 들어 `eth_subscribe` 구독 업데이트를 `{ subscription: string, result: unknown }` 형식으로 발생시켰습니다.
