---
eip: 1559
title: ETH 1.0 체인을 위한 수수료 시장 변경
author: Vitalik Buterin (@vbuterin), Eric Conner (@econoar), Rick Dudley (@AFDudley), Matthew Slipper (@mslipper), Ian Norden (@i-norden), Abdelhamid Bakhta (@abdelhamidbakhta)
discussions-to: https://ethereum-magicians.org/t/eip-1559-fee-market-change-for-eth-1-0-chain/2783
status: Final
type: Standards Track
category: Core
created: 2019-04-13
requires: 2718, 2930
lang: ko
original: ../eip-1559.md
---

## 간단한 요약
소각되는 블록당 고정 네트워크 수수료와 일시적인 혼잡을 처리하기 위해 동적으로 블록 크기를 확장/축소하는 트랜잭션 가격 책정 메커니즘입니다.

## 요약
우리는 `0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])` 형식의 새로운 [EIP-2718](./eip-2718.md) 트랜잭션 유형을 도입합니다.

프로토콜에 가스당 기본 수수료가 있으며, 이는 부모 블록에서 사용된 가스와 부모 블록의 가스 목표(블록 가스 한도를 탄력성 승수로 나눈 값)의 함수인 공식에 따라 각 블록마다 상승 또는 하락할 수 있습니다.
이 알고리즘은 블록이 가스 목표를 초과할 때 가스당 기본 수수료가 증가하고, 목표 미만일 때 감소하는 결과를 가져옵니다.
가스당 기본 수수료는 소각됩니다.
트랜잭션은 채굴자가 트랜잭션을 포함하도록 인센티브를 주기 위해 채굴자에게 지불할 의향이 있는 가스당 최대 수수료(일명: 우선 수수료)를 지정합니다.
트랜잭션은 또한 우선 수수료와 블록의 가스당 네트워크 수수료(일명: 기본 수수료)를 모두 포함하여 총 지불할 의향이 있는 가스당 최대 수수료(일명: 최대 수수료)를 지정합니다.
발신자는 항상 트랜잭션이 포함된 블록의 가스당 기본 수수료를 지불하며, 두 수수료의 합산 금액이 트랜잭션의 가스당 최대 수수료를 초과하지 않는 한 트랜잭션에 설정된 가스당 우선 수수료를 지불합니다.

## 동기
이더리움은 역사적으로 단순한 경매 메커니즘을 사용하여 트랜잭션 수수료를 책정했습니다. 사용자는 입찰("가스 가격")과 함께 트랜잭션을 보내고 채굴자는 가장 높은 입찰이 있는 트랜잭션을 선택하며, 포함된 트랜잭션은 지정한 입찰을 지불합니다. 이로 인해 여러 가지 큰 비효율성이 발생합니다:

* **트랜잭션 수수료 수준의 변동성과 트랜잭션의 사회적 비용 간의 불일치**: 블록이 가득 찰 만큼 사용량이 충분한 성숙한 퍼블릭 블록체인에서 트랜잭션 포함을 위한 입찰은 매우 변동이 심한 경향이 있습니다. 가스당 비용이 10 nanoeth일 때와 1 nanoeth일 때 네트워크가 블록에 하나의 트랜잭션을 더 수락함으로써 발생하는 비용이 실제로 10배 더 많다고 제안하는 것은 터무니없습니다; 두 경우 모두 8백만 가스와 8.02백만 가스의 차이입니다.
* **사용자의 불필요한 지연**: 블록당 고정 가스 한도와 트랜잭션 볼륨의 자연스러운 변동성으로 인해 트랜잭션은 종종 포함되기 전에 여러 블록을 기다리지만, 이는 사회적으로 비생산적입니다; 한 블록은 더 크고 다음 블록은 더 작게 하여 블록별 수요 차이를 충족할 수 있는 "여유" 메커니즘이 없다는 사실에서 누구도 크게 이득을 얻지 못합니다.
* **1차 가격 경매의 비효율성**: 현재 접근 방식에서 트랜잭션 발신자는 최대 수수료의 입찰과 함께 트랜잭션을 게시하고, 채굴자는 가장 높은 지불 트랜잭션을 선택하며, 모두가 자신이 입찰한 금액을 지불합니다. 이것은 메커니즘 설계 문헌에서 매우 비효율적인 것으로 잘 알려져 있으며, 따라서 복잡한 수수료 추정 알고리즘이 필요합니다. 하지만 이러한 알고리즘조차 종종 잘 작동하지 않아 빈번한 수수료 과다 지불로 이어집니다.
* **블록 보상이 없는 블록체인의 불안정성**: 장기적으로 발행이 없는 블록체인(비트코인과 Zcash 포함)은 현재 트랜잭션 수수료만으로 채굴자에게 보상하도록 전환할 예정입니다. 그러나 이로 인해 많은 불안정성을 유발하는 알려진 문제가 있으며, 트랜잭션 수수료를 훔치는 "자매 블록" 채굴을 인센티브화하고, 훨씬 강력한 이기적 채굴 공격 벡터를 열어주는 등의 문제가 있습니다. 현재 이에 대한 좋은 완화책이 없습니다.

이 EIP의 제안은 네트워크가 얼마나 혼잡한지에 따라 프로토콜에 의해 상하로 조정되는 기본 수수료 금액으로 시작하는 것입니다. 네트워크가 블록당 목표 가스 사용량을 초과하면 기본 수수료가 약간 증가하고, 용량이 목표 미만이면 약간 감소합니다. 이러한 기본 수수료 변경은 제한되어 있기 때문에 블록 간 기본 수수료의 최대 차이는 예측 가능합니다. 이를 통해 지갑은 매우 신뢰할 수 있는 방식으로 사용자의 가스 수수료를 자동 설정할 수 있습니다. 대부분의 사용자는 네트워크 활동이 높은 기간에도 수동으로 가스 수수료를 조정할 필요가 없을 것으로 예상됩니다. 대부분의 사용자에게 기본 수수료는 지갑에서 추정되고 채굴자에게 고아 위험을 보상하는 작은 우선 수수료(예: 1 nanoeth)가 자동으로 설정됩니다. 사용자는 총 비용을 제한하기 위해 트랜잭션 최대 수수료를 수동으로 설정할 수도 있습니다.

이 수수료 시스템의 중요한 측면은 채굴자가 우선 수수료만 유지한다는 것입니다. 기본 수수료는 항상 소각됩니다(즉, 프로토콜에 의해 파괴됩니다). 이렇게 하면 이더리움에서 트랜잭션 비용을 지불하는 데 ETH만 사용할 수 있게 되어 이더리움 플랫폼 내에서 ETH의 경제적 가치를 공고히 하고 채굴자 추출 가능 가치(MEV)와 관련된 위험을 줄입니다. 또한 이 소각은 블록 보상과 우선 수수료를 채굴자에게 제공하면서 이더리움 인플레이션을 상쇄합니다. 마지막으로, 블록 채굴자가 기본 수수료를 받지 못하도록 하는 것은 사용자로부터 더 많은 수수료를 추출하기 위해 수수료를 조작하려는 채굴자 인센티브를 제거하기 때문에 중요합니다.

## 사양
블록 유효성은 아래 참조 구현에 정의되어 있습니다.
`GASPRICE` (`0x3a`) 옵코드는 아래 참조 구현에 정의된 대로 `effective_gas_price`를 **반드시** 반환**해야 합니다(MUST)**.

`FORK_BLOCK_NUMBER`부터 `TransactionType` 2인 새로운 [EIP-2718](./eip-2718.md) 트랜잭션이 도입됩니다.

새 트랜잭션의 고유 비용은 [EIP-2930](./eip-2930.md)에서 상속되며, 구체적으로 `21000 + 16 * 0이 아닌 콜데이터 바이트 + 4 * 0인 콜데이터 바이트 + 1900 * 액세스 리스트 스토리지 키 수 + 2400 * 액세스 리스트 주소 수`입니다.

이 트랜잭션의 [EIP-2718](./eip-2718.md) `TransactionPayload`는 `rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s])`입니다.

이 트랜잭션의 `signature_y_parity, signature_r, signature_s` 요소는 `keccak256(0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list]))`에 대한 secp256k1 서명을 나타냅니다.

이 트랜잭션의 [EIP-2718](./eip-2718.md) `ReceiptPayload`는 `rlp([status, cumulative_transaction_gas_used, logs_bloom, logs])`입니다.

*참고: `//`는 정수 나눗셈, 내림입니다.*

```python
from typing import Union, Dict, Sequence, List, Tuple, Literal
from dataclasses import dataclass, field
from abc import ABC, abstractmethod

@dataclass
class TransactionLegacy:
	signer_nonce: int = 0
	gas_price: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	v: int = 0
	r: int = 0
	s: int = 0

@dataclass
class Transaction2930Payload:
	chain_id: int = 0
	signer_nonce: int = 0
	gas_price: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	access_list: List[Tuple[int, List[int]]] = field(default_factory=list)
	signature_y_parity: bool = False
	signature_r: int = 0
	signature_s: int = 0

@dataclass
class Transaction2930Envelope:
	type: Literal[1] = 1
	payload: Transaction2930Payload = Transaction2930Payload()

@dataclass
class Transaction1559Payload:
	chain_id: int = 0
	signer_nonce: int = 0
	max_priority_fee_per_gas: int = 0
	max_fee_per_gas: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	access_list: List[Tuple[int, List[int]]] = field(default_factory=list)
	signature_y_parity: bool = False
	signature_r: int = 0
	signature_s: int = 0

@dataclass
class Transaction1559Envelope:
	type: Literal[2] = 2
	payload: Transaction1559Payload = Transaction1559Payload()

Transaction2718 = Union[Transaction1559Envelope, Transaction2930Envelope]

Transaction = Union[TransactionLegacy, Transaction2718]

@dataclass
class NormalizedTransaction:
	signer_address: int = 0
	signer_nonce: int = 0
	max_priority_fee_per_gas: int = 0
	max_fee_per_gas: int = 0
	gas_limit: int = 0
	destination: int = 0
	amount: int = 0
	payload: bytes = bytes()
	access_list: List[Tuple[int, List[int]]] = field(default_factory=list)

@dataclass
class Block:
	parent_hash: int = 0
	uncle_hashes: Sequence[int] = field(default_factory=list)
	author: int = 0
	state_root: int = 0
	transaction_root: int = 0
	transaction_receipt_root: int = 0
	logs_bloom: int = 0
	difficulty: int = 0
	number: int = 0
	gas_limit: int = 0  # 참고: gas_limit은 gas_target * ELASTICITY_MULTIPLIER입니다
	gas_used: int = 0
	timestamp: int = 0
	extra_data: bytes = bytes()
	proof_of_work: int = 0
	nonce: int = 0
	base_fee_per_gas: int = 0

@dataclass
class Account:
	address: int = 0
	nonce: int = 0
	balance: int = 0
	storage_root: int = 0
	code_hash: int = 0

INITIAL_BASE_FEE = 1000000000
INITIAL_FORK_BLOCK_NUMBER = 10  # TBD
BASE_FEE_MAX_CHANGE_DENOMINATOR = 8
ELASTICITY_MULTIPLIER = 2
```

## 하위 호환성
레거시 이더리움 트랜잭션은 여전히 작동하고 블록에 포함되지만, 새로운 가격 시스템의 직접적인 혜택을 받지는 못합니다. 이는 레거시 트랜잭션에서 새 트랜잭션으로 업그레이드하면 레거시 트랜잭션의 `gas_price`가 `base_fee_per_gas`와 `priority_fee_per_gas`에 의해 완전히 소비되기 때문입니다.

### 블록 해시 변경
블록 해시를 계산하기 위해 keccak256에 전달되는 데이터 구조가 변경되며, 블록이 유효한지 검증하거나 블록 해시를 사용하여 블록 내용을 확인하는 모든 애플리케이션은 새 데이터 구조(항목 하나 추가)를 지원하도록 적응해야 합니다. 블록 헤더 바이트만 가져와서 해시하면 여전히 올바르게 해시를 얻을 수 있지만, 구성 요소에서 블록 헤더를 구성하는 경우 끝에 새 항목을 추가해야 합니다.

### GASPRICE
이 변경 이전에 `GASPRICE`는 트랜잭션에 대해 서명자가 가스당 지불하는 ETH와 채굴자가 가스당 받는 ETH를 모두 나타냈습니다. 이 변경 이후 `GASPRICE`는 이제 서명자가 가스당 지불하는 ETH 금액만 나타내며, 채굴자가 트랜잭션에 대해 받은 금액은 더 이상 EVM에서 직접 액세스할 수 없습니다.

## 보안 고려사항
### 최대 블록 크기/복잡성 증가
이 EIP는 최대 블록 크기를 증가시키며, 채굴자가 블록을 충분히 빠르게 처리할 수 없는 경우 빈 블록을 채굴하도록 강제하므로 문제가 발생할 수 있습니다. 시간이 지남에 따라 평균 블록 크기는 이 EIP가 없을 때와 거의 동일하게 유지되어야 하므로 이것은 단기적인 크기 급증에 대한 문제일 뿐입니다. 하나 이상의 클라이언트가 단기적인 크기 급증을 제대로 처리하지 못하고 오류(메모리 부족 등)가 발생할 수 있으며, 클라이언트 구현은 클라이언트가 최대 크기까지 개별 블록을 적절히 처리할 수 있는지 확인해야 합니다.

### 트랜잭션 순서
대부분의 사람들이 우선 수수료를 경쟁하지 않고 대신 포함을 위한 기준선 수수료를 사용하므로, 트랜잭션 순서는 이제 메모리에 트랜잭션을 저장하는 방법과 같은 개별 클라이언트 내부 구현 세부 사항에 따라 달라집니다. 동일한 우선 수수료를 가진 트랜잭션은 트랜잭션이 수신된 시간순으로 정렬하여 공격자가 유리한 위치에 하나 이상의 트랜잭션이 도착하도록 대기 풀에 많은 트랜잭션을 던지는 스팸 공격으로부터 네트워크를 보호하는 것이 권장됩니다. 채굴자는 순전히 이기적인 채굴 관점에서 낮은 가스 프리미엄보다 높은 가스 프리미엄 트랜잭션을 선호해야 합니다.

### 채굴자의 빈 블록 채굴
채굴자가 기본 수수료가 매우 낮아질 때까지 빈 블록을 채굴한 다음 반쯤 찬 블록을 채굴하고 우선 수수료로 트랜잭션을 정렬하는 것으로 되돌아갈 수 있습니다. 이 공격이 가능하지만, 채굴이 분산화되어 있는 한 특별히 안정적인 균형은 아닙니다. 이 전략에서 이탈하는 사람은 공격이 계속되는 한(기본 수수료가 0에 도달한 후에도) 공격에 참여하는 채굴자보다 더 수익성이 있습니다. 어떤 채굴자든 익명으로 카르텔에서 이탈할 수 있고 특정 채굴자가 이탈했음을 증명할 방법이 없으므로, 이 공격을 실행하는 유일한 실현 가능한 방법은 해싱 파워의 50% 이상을 통제하는 것입니다. 공격자가 정확히 50%의 해싱 파워를 가지고 있다면 이탈자가 우선 수수료에서 두 배의 이더를 버는 동안 우선 수수료에서 이더를 벌지 못할 것입니다. 공격자가 수익을 내려면 50% 이상의 해싱 파워가 필요하며, 이는 대신 이중 지불 공격을 실행하거나 단순히 다른 채굴자를 무시할 수 있음을 의미하며 이것이 훨씬 더 수익성 있는 전략입니다.

채굴자가 이 공격을 실행하려고 시도하면 탄력성 승수(현재 2x)를 단순히 증가시켜 이탈자에 대해 공격이 이론적으로 수익성이 되기 전에 더 많은 해싱 파워가 필요하게 할 수 있습니다.

### ETH 소각으로 인한 고정 공급 불가
기본 수수료를 소각함으로써 더 이상 고정된 이더 공급을 보장할 수 없습니다. 이로 인해 ETH의 장기 공급이 시간이 지남에 따라 더 이상 일정하지 않아 경제적 불안정성이 발생할 수 있습니다. 이것은 타당한 우려이지만, 이것이 얼마나 영향을 미칠지 정량화하기 어렵습니다. 채굴 보상보다 기본 수수료에서 더 많이 소각되면 ETH는 디플레이션이 되고, 소각된 것보다 채굴 보상에서 더 많이 생성되면 ETH는 인플레이션이 됩니다. 블록 공간에 대한 사용자 수요를 통제할 수 없으므로 현재 ETH가 인플레이션이 될지 디플레이션이 될지 주장할 수 없어 이 변경으로 인해 코어 개발자는 이더의 장기 수량에 대한 일부 통제력을 잃게 됩니다.

## 저작권
저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.
