---
eip: 2124
title: 체인 호환성 검사를 위한 포크 식별자
author: Péter Szilágyi <peterke@gmail.com>, Felix Lange <fjl@ethereum.org>
discussions-to: https://github.com/ethereum/EIPs/issues/2125
status: Final
type: Standards Track
category: Networking
created: 2019-05-03
lang: ko
original: ../eip-2124.md
---

## 간단한 요약

현재 이더리움 네트워크의 노드들은 이더리움 노드처럼 "보이는" 원격 머신(공용 네트워크, 사설 네트워크, 테스트 네트워크 등)에 무작위 연결을 설정하여 서로를 찾으려 하며, 유용한 피어(동일한 제네시스, 동일한 포크)를 찾기를 바랍니다. 이것은 특히 소규모 네트워크에서 시간과 자원을 낭비합니다.

이 오버헤드를 피하기 위해, 이더리움은 노드가 유용할지 아닐지를 가능한 한 빨리 정확하게 식별할 수 있는 메커니즘이 필요합니다. 이러한 메커니즘은 체인 구성을 요약하는 방법과 네트워크에서 해당 요약을 배포하는 방법이 필요합니다.

이 제안은 해당 요약의 정의 - 일반적으로 유용한 *포크 식별자* - 와 그 검증 규칙에만 초점을 맞추어, 임의의 네트워크 프로토콜(예: [발견 ENR](./eip-778.md) 또는 `eth/6x` 핸드셰이크)에 포함될 수 있도록 합니다.

## 요약

많은 공용 및 사설 이더리움 네트워크가 있지만, 발견 프로토콜은 이들을 구분하지 않습니다. 피어가 좋은지 나쁜지(같은 체인인지 아닌지)를 확인하는 유일한 방법은 TCP/IP 연결을 설정하고, RLPx 암호화로 감싸고, `eth` 핸드셰이크를 실행하는 것입니다. 원격 피어가 다른 네트워크에 있는 것으로 밝혀지면 이는 감당하기 힘든 극단적인 비용이며, 이더리움과 이더리움 클래식을 구분할 만큼 정확하지도 않습니다. 이 비용은 좋은 노드를 찾기 위해 훨씬 더 많은 시행착오가 필요한 소규모 네트워크에서 더욱 증폭됩니다.

피어가 동일한 체인에 **있더라도**, 논쟁의 여지가 없는 합의 업그레이드 중에 모든 사람이 제때 노드를 업데이트하지는 않습니다(개발자 노드, 잔류 노드 등). 이러한 오래된 노드는 좋은 노드에 들러붙지만 업그레이드된 블록을 수락하지 않기 때문에 피어 투 피어 네트워크에 무의미한 부담을 줍니다. 이로 인해 오래된 노드가 마침내 업데이트될 때까지 귀중한 피어 슬롯과 대역폭이 손실됩니다. 이것은 잔류 노드가 몇 달 동안 남아 있을 수 있는 테스트 네트워크에서 심각한 문제입니다.

이 EIP는 체인의 현재 상태(제네시스와 적용된 모든 포크)를 정확하고 간결하게 요약하는 새로운 신원 체계를 제안합니다. 간결함은 특히 데이터그램 프로토콜에서도 신원을 유용하게 만드는 데 중요합니다. 이 EIP는 여러 문제를 해결합니다:

 * 두 노드가 다른 네트워크에 있다면, 연결을 고려조차 하지 않아야 합니다.
 * 하드 포크가 통과하면, 업그레이드된 노드는 업그레이드되지 않은 노드를 거부해야 하지만, 그 **이전에는** 안 됩니다.
 * 두 체인이 같은 제네시스를 공유하지만 포크가 다르면(ETH / ETC), 서로를 거부해야 합니다.

이 EIP는 3방향 포크의 깔끔한 분리를 해결하려고 시도하지 않습니다! 같은 미래 블록 번호에서 네트워크가 세 개(비포크, 포크-A, 포크-B)로 분할되면, 포크 참여자들 사이를 분리하는 것은 사례별 특별 처리가 필요합니다. 이를 처리하지 않으면 제안이 실용적이고 단순해지며, 메인넷에서 포크하기가 너무 쉬워지는 것도 방지합니다.

범위를 제한하기 위해, 이 EIP는 신원 체계와 검증 규칙만 정의합니다. 동일한 체계와 알고리즘은 다양한 네트워킹 프로토콜에 포함될 수 있어, `eth/6x` 핸드셰이크가 더 정확해지고(이더리움 vs. 이더리움 클래식); 발견도 더 유용해집니다(연결하지 않고도 확실히 피어를 거부).

## 동기

피어 투 피어 네트워킹은 방화벽과 네트워크 주소 변환(NAT) 때문에 복잡하고 어렵습니다. 일반적으로 노드의 작은 부분만이 공개적으로 라우팅 가능한 주소를 가지며, P2P 네트워크는 주로 다른 모든 사람을 위해 데이터를 전달하는 데 이들에 의존합니다. 공용 노드의 유용성을 최대화하는 가장 좋은 방법은 그들의 자원이 네트워크에 쓸모없는 작업에 낭비되지 않도록 하는 것입니다.

호환되지 않는 노드들을 서로 적극적으로 차단함으로써 공용 노드에서 훨씬 더 많은 가치를 추출할 수 있어, 전체 P2P 네트워크가 훨씬 더 견고하고 신뢰할 수 있게 됩니다. 발견 계층에서 이 네트워크 파티셔닝을 지원하면 처음부터 스트림 연결 설정과 관련된 비용이 많이 드는 암호화 및 지연/대역폭 히트를 피할 수 있어 성능이 더욱 향상될 수 있습니다.

## 명세

각 노드는 다음 값을 유지합니다:

- **`FORK_HASH`**: 제네시스 해시와 이미 지난 포크 블록 번호의 IEEE CRC32 체크섬 (`[4]byte`).
  - 포크 블록 번호는 오름차순으로 CRC32 체크섬에 입력됩니다.
  - 여러 포크가 같은 블록에 적용되면, 블록 번호는 한 번만 체크섬됩니다.
  - 블록 번호는 `uint64` 정수로 간주되며, 체크섬할 때 빅 엔디언 포맷으로 인코딩됩니다.
  - 체인이 제네시스에서 이미 비프론티어 규칙 세트로 시작하도록 구성된 경우, 이는 포크로 간주되지 않습니다.
- **`FORK_NEXT`**: 다음 예정된 포크의 블록 번호 (`uint64`), 또는 알려진 다음 포크가 없으면 `0`.

예를 들어, 메인넷의 `FORK_HASH`는 다음과 같습니다:

- forkhash₀ = `0xfc64ec04` (제네시스) = `CRC32(<genesis-hash>)`
- forkhash₁ = `0x97c2c34c` (홈스테드) = `CRC32(<genesis-hash> || uint64(1150000))`
- forkhash₂ = `0x91d1f948` (DAO 포크) = `CRC32(<genesis-hash> || uint64(1150000) || uint64(1920000))`

*포크 식별자*는 `RLP([FORK_HASH, FORK_NEXT])`로 정의됩니다. 이 `forkid`는 원격 체인의 호환성을 평가하기 위해 교차 검증됩니다(단순히 비교하지 **않음**). 포크 상태와 관계없이, 양측은 한쪽에서의 무한 재연결 시도를 피하기 위해 동일한 결론에 도달해야 합니다.

#### 검증 규칙

- 1) 로컬과 원격 `FORK_HASH`가 일치하면, 로컬 헤드를 `FORK_NEXT`와 비교합니다.
  - 두 노드가 현재 같은 포크 상태에 있습니다. 미래의 다른 포크를 알 수 있지만, 포크가 트리거될 때까지는 관련이 없습니다(연기될 수 있고, 노드가 업데이트되어 일치할 수 있음).
    - 1a) 원격에서 발표했지만 원격에서 아직 지나지 않은 블록이 로컬에서는 이미 지났으면, 체인이 호환되지 않으므로 연결을 끊습니다.
    - 1b) 원격에서 발표된 포크가 없거나; 로컬에서 아직 지나지 않았으면, 연결합니다.

- 2) 원격 `FORK_HASH`가 로컬 과거 포크의 부분집합이고 원격 `FORK_NEXT`가 로컬의 다음 포크 블록 번호와 일치하면, 연결합니다.
  - 원격 노드가 현재 동기화 중입니다. 결국 우리와 분기될 수 있지만, 현재 시점에서는 충분한 정보가 없습니다.
- 3) 원격 `FORK_HASH`가 로컬 과거 포크의 상위집합이고 로컬에서 알려진 미래 포크로 완성될 수 있으면, 연결합니다.
  - 로컬 노드가 현재 동기화 중입니다. 결국 원격과 분기될 수 있지만, 현재 시점에서는 충분한 정보가 없습니다.
- 4) 다른 모든 경우에는 거부합니다.

#### 오래된 소프트웨어 예시

아래 예시는 노드가 일치하는 소프트웨어 버전을 실행하지 않지만 동일한 체인(메인넷 노드, 테스트넷 노드 등)을 따르는 경우 발생하는 포크 조합 가능성을 포괄하려고 시도합니다.

| 과거 포크 | 미래 포크 | 헤드 | 원격 `FORK_HASH` | 원격 `FORK_NEXT` | 연결 | 이유 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| A | | | A | | 예 (1b) | 같은 포크, 같은 동기화 상태. |
| A | | < B | A | B | 예 (1b) | 원격이 미래 포크를 광고하지만, 불확실함. |
| A | | >= B | A | B | 아니오 (1a) | 원격이 로컬에서 지난 미래 포크를 광고함. |
| A | B | | A |  | 예 (1b) | 로컬이 미래 포크를 알고 있지만, 불확실함. |
| A | B | | A | B | 예 (1b) | 둘 다 미래 포크를 알고 있지만, 불확실함. |
| A | B1 | < B2 | A | B2 | 예 (1b) | 둘 다 다른 미래 포크를 알고 있지만, 불확실함. |
| A | B1 | >= B2 | A | B2 | 아니오 (1a) | 둘 다 다른 미래 포크를 알고 있지만, 원격 포크가 로컬에서 지남. |
| [A,B] | | | A | B | 예 (2) | 원격이 동기화되지 않음. |
| [A,B,C] | | | A | B | 예¹ (2) | 원격이 동기화되지 않음. 원격은 소프트웨어 업데이트가 필요하지만, 아직 모름. |
| A | B | | A ⊕ B | | 예 (3) | 로컬이 동기화되지 않음. |
| A | B,C | | A ⊕ B | | 예 (3) | 로컬이 동기화되지 않음. 로컬도 미래 포크를 알고 있지만, 아직 불확실함. |
| A | | | A ⊕ B | | 아니오 (4) | 로컬에 소프트웨어 업데이트 필요. |
| A | B | | A ⊕ B ⊕ C | | 아니오² (4) | 로컬에 소프트웨어 업데이트 필요. |
| [A,B] | | | A | | 아니오 (4) | 원격에 소프트웨어 업데이트 필요. |

*참고, 표에 ¹과 ²로 표시된 비대칭이 하나 있습니다. 원격 노드의 미래 포크 목록(다음 것만 있음)에 접근할 수 없기 때문에, 동기화될 때까지 소프트웨어가 오래되었음을 감지할 수 없습니다. 이것은 1) 원격 노드가 어쨌든 우리와 연결을 끊을 것이고, 2) 이것은 동기화 중의 일시적인 문제이지 잔류 노드와의 영구적인 문제가 아니기 때문에 수용 가능합니다.*

## 근거

##### `FORK_HASH`를 4바이트로 평탄화하는 이유? 전체 제네시스와 포크 목록을 공유하지 않는 이유?

`eth` devp2p 프로토콜은 임의의 많은 데이터를 전송할 수 있지만, 발견 프로토콜의 모든 ENR 항목에 대한 총 공간 허용량은 300바이트입니다.

`FORK_HASH`를 4바이트 체크섬으로 줄이면 향후 확장을 위한 충분한 공간이 ENR에 남습니다; 그리고 4바이트는 (실용적인) 충돌 관점에서 임의의 많은 이더리움 네트워크에 충분합니다.

##### Keccak256 대신 IEEE CRC32를 체크섬으로 사용하는 이유?

입력을 무시하지 않고 임의의 데이터를 4바이트로 평탄화할 수 있는 메커니즘이 필요합니다. 다른 체크섬이나 해싱 알고리즘도 작동하지만, 노드가 언제든지 거짓말을 할 수 있으므로 암호화 해시 함수에 가치가 없습니다.

Keccak256 해시의 처음 4바이트를 취하는 것(이상해 보임)이나 모든 4바이트 그룹을 XOR하는 것(지저분함) 대신, CRC32가 정확히 이를 위해 설계되었으므로 더 나은 대안입니다. IEEE CRC32는 이더넷, gzip, zip, png 등에서도 사용되므로, 모든 프로그래밍 언어 지원이 문제가 되지 않습니다.

##### `FORK_NEXT`를 많이 사용하지 않는데, 어떻게든 제거할 수 없나요?

원격 노드가 동기화되지 않은 것인지 소프트웨어가 오래된 것인지 구별할 수 있어야 합니다. 과거 포크만 공유하면 노드가 정당하게 뒤처진 것인지 막힌 것인지 알 수 없습니다.

##### `FORK_HASH`처럼 알려진 모든 미래 포크를 "해싱"하는 대신 다음 포크 하나만 광고하는 이유?

이미 지난(우리에게 로컬로) 과거 포크는 불변으로 간주될 수 있지만, 미래 포크에 대해서는 아무것도 모릅니다. 우리가 동기화되지 않았거나 포크가 아직 지나지 않았을 수 있습니다. 아직 지나지 않았다면 연기될 수 있으므로, 강제하면 네트워크가 분열될 것입니다. 또한 아직 모든 미래 포크를 알지 못할 수도 있습니다(한동안 소프트웨어를 업데이트하지 않았을 경우).

## 역호환성

이 EIP는 신원 체계만 정의하며, 기능적 변경을 정의하지 않습니다.

## 테스트 케이스

피터스버그 포크 상한(작성 시점)이 주어졌을 때 메인넷, Ropsten, Rinkeby, Görli가 광고할 수 있는 모든 가능한 포크 ID에 대한 전체 테스트 모음입니다.

```go
type testcase struct {
	head uint64
	want ID
}
tests := []struct {
	config  *params.ChainConfig
	genesis common.Hash
	cases   []testcase
}{
	// 메인넷 테스트 케이스
	{
		params.MainnetChainConfig,
		params.MainnetGenesisHash,
		[]testcase{
			{0, ID{Hash: 0xfc64ec04, Next: 1150000}},       // 동기화되지 않음
			{1149999, ID{Hash: 0xfc64ec04, Next: 1150000}}, // 마지막 프론티어 블록
			{1150000, ID{Hash: 0x97c2c34c, Next: 1920000}}, // 첫 홈스테드 블록
			{1919999, ID{Hash: 0x97c2c34c, Next: 1920000}}, // 마지막 홈스테드 블록
			{1920000, ID{Hash: 0x91d1f948, Next: 2463000}}, // 첫 DAO 블록
			{2462999, ID{Hash: 0x91d1f948, Next: 2463000}}, // 마지막 DAO 블록
			{2463000, ID{Hash: 0x7a64da13, Next: 2675000}}, // 첫 탠저린 블록
			{2674999, ID{Hash: 0x7a64da13, Next: 2675000}}, // 마지막 탠저린 블록
			{2675000, ID{Hash: 0x3edd5b10, Next: 4370000}}, // 첫 스퓨리어스 블록
			{4369999, ID{Hash: 0x3edd5b10, Next: 4370000}}, // 마지막 스퓨리어스 블록
			{4370000, ID{Hash: 0xa00bc324, Next: 7280000}}, // 첫 비잔티움 블록
			{7279999, ID{Hash: 0xa00bc324, Next: 7280000}}, // 마지막 비잔티움 블록
			{7280000, ID{Hash: 0x668db0af, Next: 0}},       // 첫/마지막 콘스탄티노플, 첫 피터스버그 블록
			{7987396, ID{Hash: 0x668db0af, Next: 0}},       // 오늘 피터스버그 블록
		},
	},
	// Ropsten 테스트 케이스
	{
		params.TestnetChainConfig,
		params.TestnetGenesisHash,
		[]testcase{
			{0, ID{Hash: 0x30c7ddbc, Next: 10}},            // 동기화되지 않음, 마지막 프론티어, 홈스테드, 첫 탠저린 블록
			{9, ID{Hash: 0x30c7ddbc, Next: 10}},            // 마지막 탠저린 블록
			{10, ID{Hash: 0x63760190, Next: 1700000}},      // 첫 스퓨리어스 블록
			{1699999, ID{Hash: 0x63760190, Next: 1700000}}, // 마지막 스퓨리어스 블록
			{1700000, ID{Hash: 0x3ea159c7, Next: 4230000}}, // 첫 비잔티움 블록
			{4229999, ID{Hash: 0x3ea159c7, Next: 4230000}}, // 마지막 비잔티움 블록
			{4230000, ID{Hash: 0x97b544f3, Next: 4939394}}, // 첫 콘스탄티노플 블록
			{4939393, ID{Hash: 0x97b544f3, Next: 4939394}}, // 마지막 콘스탄티노플 블록
			{4939394, ID{Hash: 0xd6e2149b, Next: 6485846}}, // 첫 피터스버그 블록
			{6485845, ID{Hash: 0xd6e2149b, Next: 6485846}}, // 마지막 피터스버그 블록
			{6485846, ID{Hash: 0x4bc66396, Next: 0}},       // 첫 이스탄불 블록
			{7500000, ID{Hash: 0x4bc66396, Next: 0}},       // 미래 이스탄불 블록
		},
	},
	// Rinkeby 테스트 케이스
	{
		params.RinkebyChainConfig,
		params.RinkebyGenesisHash,
		[]testcase{
			{0, ID{Hash: 0x3b8e0691, Next: 1}},             // 동기화되지 않음, 마지막 프론티어 블록
			{1, ID{Hash: 0x60949295, Next: 2}},             // 첫/마지막 홈스테드 블록
			{2, ID{Hash: 0x8bde40dd, Next: 3}},             // 첫/마지막 탠저린 블록
			{3, ID{Hash: 0xcb3a64bb, Next: 1035301}},       // 첫 스퓨리어스 블록
			{1035300, ID{Hash: 0xcb3a64bb, Next: 1035301}}, // 마지막 스퓨리어스 블록
			{1035301, ID{Hash: 0x8d748b57, Next: 3660663}}, // 첫 비잔티움 블록
			{3660662, ID{Hash: 0x8d748b57, Next: 3660663}}, // 마지막 비잔티움 블록
			{3660663, ID{Hash: 0xe49cab14, Next: 4321234}}, // 첫 콘스탄티노플 블록
			{4321233, ID{Hash: 0xe49cab14, Next: 4321234}}, // 마지막 콘스탄티노플 블록
			{4321234, ID{Hash: 0xafec6b27, Next: 5435345}}, // 첫 피터스버그 블록
			{5435344, ID{Hash: 0xafec6b27, Next: 5435345}}, // 마지막 피터스버그 블록
			{5435345, ID{Hash: 0xcbdb8838, Next: 0}},       // 첫 이스탄불 블록
			{6000000, ID{Hash: 0xcbdb8838, Next: 0}},       // 미래 이스탄불 블록
		},
	},
	// Goerli 테스트 케이스
	{
		params.GoerliChainConfig,
		params.GoerliGenesisHash,
		[]testcase{
			{0, ID{Hash: 0xa3f5ab08, Next: 1561651}},       // 동기화되지 않음, 마지막 프론티어, 홈스테드, 탠저린, 스퓨리어스, 비잔티움, 콘스탄티노플, 첫 피터스버그 블록
			{1561650, ID{Hash: 0xa3f5ab08, Next: 1561651}}, // 마지막 피터스버그 블록
			{1561651, ID{Hash: 0xc25efa5c, Next: 0}},       // 첫 이스탄불 블록
			{2000000, ID{Hash: 0xc25efa5c, Next: 0}},       // 미래 이스탄불 블록
		},
	},
}
```

메인넷 노드가 있을 수 있는 다양한 상태와 검증하고 수락 또는 거부 결정을 내려야 할 다양한 원격 포크 식별자에 대한 테스트 모음입니다:

```go
tests := []struct {
	head uint64
	id   ID
	err  error
}{
	// 로컬은 메인넷 피터스버그, 원격도 동일하게 발표. 미래 포크 발표 없음.
	{7987396, ID{Hash: 0x668db0af, Next: 0}, nil},

	// 로컬은 메인넷 피터스버그, 원격도 동일하게 발표. 원격은 또한 블록 0xffffffff에서
	// 다음 포크를 발표하지만, 이는 불확실함.
	{7987396, ID{Hash: 0x668db0af, Next: math.MaxUint64}, nil},

	// 로컬은 현재 비잔티움에만 있는 메인넷(피터스버그 알고 있음), 원격도 비잔티움을 발표하지만,
	// 아직 피터스버그를 모름(예: 포크 전에 업데이트되지 않은 노드).
	// 이 경우 피터스버그가 지났는지 아닌지 모름.
	{7279999, ID{Hash: 0xa00bc324, Next: 0}, nil},

	// 로컬은 현재 비잔티움에만 있는 메인넷(피터스버그 알고 있음), 원격도 비잔티움을 발표하고,
	// 피터스버그도 알고 있음(예: 포크 전에 업데이트된 노드). 피터스버그가 지났는지(지날 것인지)
	// 아닌지 모름.
	{7279999, ID{Hash: 0xa00bc324, Next: 7280000}, nil},

	// 로컬은 현재 비잔티움에만 있는 메인넷(피터스버그 알고 있음), 원격도 비잔티움을 발표하고,
	// 어떤 랜덤 포크(예: 잘못 구성된 피터스버그)도 알고 있음. 어느 노드에서도 포크가 지나지
	// 않았으므로 일치하지 않을 수 있지만, 지금은 연결함.
	{7279999, ID{Hash: 0xa00bc324, Next: math.MaxUint64}, nil},

	// 로컬은 메인넷 피터스버그, 원격은 비잔티움 + 피터스버그 지식 발표. 원격은 단순히
	// 동기화되지 않음, 수락.
	{7987396, ID{Hash: 0xa00bc324, Next: 7280000}, nil},

	// 로컬은 메인넷 피터스버그, 원격은 스퓨리어스 + 비잔티움 지식 발표. 원격은 확실히
	// 동기화되지 않음. 피터스버그 업데이트가 필요한지 아닌지 아직 모름.
	{7987396, ID{Hash: 0x3edd5b10, Next: 4370000}, nil},

	// 로컬은 메인넷 비잔티움, 원격은 피터스버그 발표. 로컬이 동기화되지 않음, 수락.
	{7279999, ID{Hash: 0x668db0af, Next: 0}, nil},

	// 로컬은 메인넷 스퓨리어스, 원격은 비잔티움을 발표하지만 피터스버그는 모름. 로컬이
	// 동기화되지 않음. 로컬도 미래 포크를 알고 있지만, 아직 불확실함.
	{4369999, ID{Hash: 0xa00bc324, Next: 0}, nil},

	// 로컬은 메인넷 피터스버그. 원격은 비잔티움을 발표하지만 추가 포크 모름.
	// 원격에 소프트웨어 업데이트 필요.
	{7987396, ID{Hash: 0xa00bc324, Next: 0}, ErrRemoteStale},

	// 로컬은 메인넷 피터스버그, 추가 포크 모름. 원격은 피터스버그 + 0xffffffff 발표.
	// 로컬에 소프트웨어 업데이트 필요, 거부.
	{7987396, ID{Hash: 0x5cddc0e1, Next: 0}, ErrLocalIncompatibleOrStale},

	// 로컬은 메인넷 비잔티움, 피터스버그 알고 있음. 원격은 피터스버그 + 0xffffffff 발표.
	// 로컬에 소프트웨어 업데이트 필요, 거부.
	{7279999, ID{Hash: 0x5cddc0e1, Next: 0}, ErrLocalIncompatibleOrStale},

	// 로컬은 메인넷 피터스버그, 원격은 Rinkeby 피터스버그.
	{7987396, ID{Hash: 0xafec6b27, Next: 0}, ErrLocalIncompatibleOrStale},

	// 로컬은 메인넷 피터스버그, 먼 미래. 원격은 미래 블록 88888888에서 자신을 위해 Gopherium
	// (존재하지 않는 포크)을 발표하지만, 로컬에서는 과거 블록. 로컬이 호환되지 않음.
	//
	// 이 경우는 대다수 해시 파워를 가진 업그레이드되지 않은 노드를 감지함(전형적인 Ropsten 혼란).
	{88888888, ID{Hash: 0x668db0af, Next: 88888888}, ErrLocalIncompatibleOrStale},

	// 로컬은 메인넷 비잔티움. 원격도 비잔티움이지만, 피터스버그 이전 블록 7279999에서
	// Gopherium(존재하지 않는 포크)을 발표. 로컬이 호환되지 않음.
	{7279999, ID{Hash: 0xa00bc324, Next: 7279999}, ErrLocalIncompatibleOrStale},
}
```

적절한 RLP 인코딩을 검증하기 위한 몇 가지 테스트입니다(`FORK_HASH`는 4바이트 바이너리이지만 `FORK_NEXT`는 8바이트 수량이므로):

```go
tests := []struct {
  id   ID
  want []byte
}{
  {
    ID{Hash: 0, Next: 0},
    common.Hex2Bytes("c6840000000080"),
  },
  {
    ID{Hash: 0xdeadbeef, Next: 0xBADDCAFE},
    common.Hex2Bytes("ca84deadbeef84baddcafe"),
  },
  {
    ID{Hash: math.MaxUint32, Next: math.MaxUint64},
    common.Hex2Bytes("ce84ffffffff88ffffffffffffffff"),
  },
}
```

## 구현

Geth: https://github.com/ethereum/go-ethereum/tree/master/core/forkid

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기되었습니다.
