---
eip: 2718
title: 타입화된 트랜잭션 엔벨로프
description: 미래 트랜잭션 유형을 위한 엔벨로프인 새로운 트랜잭션 유형을 정의합니다.
author: Micah Zoltu (@MicahZoltu)
discussions-to: https://ethereum-magicians.org/t/eip-2718-typed-transaction-envelope/4355
status: Final
type: Standards Track
category: Core
created: 2020-06-13
lang: ko
original: ../eip-2718.md
---

## 요약
`TransactionType || TransactionPayload`는 유효한 트랜잭션이고 `TransactionType || ReceiptPayload`는 유효한 트랜잭션 영수증입니다. 여기서 `TransactionType`은 트랜잭션의 형식을 식별하고 `*Payload`는 미래 EIP에서 정의될 트랜잭션/영수증 내용입니다.

## 동기
과거에 새로운 트랜잭션 유형을 추가하려고 할 때 다른 모든 트랜잭션과 하위 호환되어야 했습니다. 이는 인코딩된 페이로드만을 기반으로 구분할 수 있어야 하며, 두 유형 모두에 일치하는 트랜잭션이 있을 수 없다는 것을 의미합니다.
이것은 [EIP-155](./eip-155.md)에서 볼 수 있었는데, 새 값이 인코딩된 필드 중 하나에 비트 패킹되었습니다.
EOA 계정이 컨텍스트 내에서 직접 코드를 실행할 수 있게 하는 것, `msg.sender`가 아닌 다른 사람이 가스를 지불할 수 있게 하는 것, 레이어 1 다중 서명 트랜잭션과 관련된 제안 등 새로운 트랜잭션 유형을 정의하는 여러 제안이 논의 중입니다.
이들 모두는 상호 호환 가능한 방식으로 정의되어야 하며, 이는 EIP 작성자와 트랜잭션 유형을 구분하기 위한 복잡한 규칙을 따라야 하는 클라이언트에게 빠르게 부담이 됩니다.

엔벨로프 트랜잭션 유형을 도입함으로써 기존 트랜잭션과의 하위 호환성만 보장하면 되고, 그 이후에는 `TransactionType` 간에 번호 충돌이 없는지 확인하는 훨씬 간단한 문제만 해결하면 됩니다.

## 사양
### 정의
* `||`는 바이트/바이트 배열 연결 연산자입니다.

### 트랜잭션
`FORK_BLOCK_NUMBER`부터 블록 헤더의 트랜잭션 루트는 **반드시** `patriciaTrie(rlp(Index) => Transaction)`의 루트 해시**여야 합니다(MUST)**. 여기서:
* `Index`는 이 트랜잭션의 블록 내 인덱스
* `Transaction`은 `TransactionType || TransactionPayload` 또는 `LegacyTransaction`
* `TransactionType`은 트랜잭션 유형을 나타내는 `0`에서 `0x7f` 사이의 양의 부호 없는 8비트 숫자
* `TransactionPayload`는 `TransactionType`에 따라 해석이 달라지고 미래 EIP에서 정의되는 불투명 바이트 배열
* `LegacyTransaction`은 `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`

미래 트랜잭션 유형의 모든 서명은 서명 데이터의 첫 번째 바이트로 `TransactionType`을 포함**해야 합니다(SHOULD)**.
이렇게 하면 한 트랜잭션 유형의 서명이 다른 트랜잭션 유형의 서명으로 사용되는 것에 대해 걱정할 필요가 없습니다.

### 영수증
`FORK_BLOCK_NUMBER`부터 블록 헤더의 영수증 루트는 **반드시** `patriciaTrie(rlp(Index) => Receipt)`의 루트 해시**여야 합니다(MUST)**. 여기서:
* `Index`는 이 영수증이 해당하는 트랜잭션의 블록 내 인덱스
* `Receipt`는 `TransactionType || ReceiptPayload` 또는 `LegacyReceipt`
* `TransactionType`은 트랜잭션 유형을 나타내는 `0`에서 `0x7f` 사이의 양의 부호 없는 8비트 숫자
* `ReceiptPayload`는 `TransactionType`에 따라 해석이 달라지고 미래 EIP에서 정의되는 불투명 바이트 배열
* `LegacyReceipt`는 `rlp([status, cumulativeGasUsed, logsBloom, logs])`

영수증의 `TransactionType`은 일치하는 `Index`를 가진 트랜잭션의 `TransactionType`과 **반드시** 일치**해야 합니다(MUST)**.

## 근거
### TransactionType은 0x7f까지만
예측 가능한 미래에 0x7f는 충분하며, 연속 비트로 상위 비트를 사용하는 것과 같이 범위를 확장하기 위한 여러 옵션을 열어둡니다.
이것은 또한 항상 `>= 0xc0` 바이트로 시작하는 레거시 트랜잭션 유형과의 충돌을 방지합니다.

### 서명 데이터의 첫 번째 바이트에 대한 TransactionType의 **MUST** 대신 **SHOULD**
서명 재사용 문제가 없도록 모든 미래 트랜잭션이 첫 번째 바이트에 서명하는 것이 강력히 권장되지만, 작성자는 이것이 항상 의미가 있거나 가능하지 않을 수 있음을 인정합니다.
이것이 불가능한 한 예는 레거시 서명 체계와 서명 호환이 되는 래핑된 레거시 트랜잭션입니다.
또 다른 잠재적 상황은 트랜잭션이 전통적인 의미의 서명을 가지지 않고 대신 유효성을 결정하는 다른 메커니즘을 가지는 경우입니다.

### 불투명 바이트 배열 vs RLP 배열
두 번째 바이트부터 불투명 바이트로 함으로써 SSZ, LEB128 또는 고정 너비 형식과 같은 트랜잭션 페이로드에 대한 다양한 인코딩 형식을 미래에 지원할 수 있습니다.

### ORIGIN 및 CALLER
각 트랜잭션 유형이 해당 옵코드가 반환하는 것을 정의할 수 있도록 ORIGIN 및 CALLER 옵코드가 트랜잭션 유형에 따라 달라지게 하는 것에 대한 논의가 있었습니다.
그러나 컨트랙트가 다른 유형의 트랜잭션을 다르게 처리하는 것을 억제하기 위해 트랜잭션 유형을 컨트랙트에 불투명하게 만들고자 하는 바람이 있습니다.
또한 ORIGIN 및 CALLER 옵코드에 대해 가정하는 기존 컨트랙트와의 하위 호환성에 대한 우려도 있었습니다.
앞으로 모든 트랜잭션 유형은 첫 번째 EVM 프레임의 `CALLER`를 합리적으로 나타내는 주소를 가지고 있다고 가정하며, `ORIGIN`은 모든 경우에 동일한 주소가 됩니다.
트랜잭션 유형이 컨트랙트에 추가 정보를 제공해야 하는 경우 새 옵코드가 필요합니다.

## 하위 호환성
클라이언트는 첫 번째 바이트를 보고 레거시 트랜잭션과 타입화된 트랜잭션을 구분할 수 있습니다.
`[0, 0x7f]` 범위의 값으로 시작하면 새 트랜잭션 유형이고, `[0xc0, 0xfe]` 범위의 값으로 시작하면 레거시 트랜잭션 유형입니다.
`0xff`는 RLP 인코딩된 트랜잭션에 현실적이지 않으므로 확장 센티넬 값으로 미래 사용을 위해 예약되어 있습니다.

## 보안 고려사항
새로운 2718 트랜잭션 유형을 설계할 때, 서명된 페이로드의 첫 번째 바이트로 트랜잭션 유형을 포함하는 것이 **강력히** 권장됩니다. 이를 하지 않으면 트랜잭션이 다른 유형의 트랜잭션과 서명 호환이 될 수 있어 사용자에게 보안 취약점을 도입할 수 있습니다.

## 저작권
저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.
