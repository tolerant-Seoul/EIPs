---
eip: 2929
title: 상태 접근 옵코드의 가스 비용 증가
author: Vitalik Buterin (@vbuterin), Martin Swende (@holiman)
discussions-to: https://ethereum-magicians.org/t/eip-2929-gas-cost-increases-for-state-access-opcodes/4558
status: Final
type: Standards Track
category: Core
created: 2020-09-01
lang: ko
original: ../eip-2929.md
---

## 간단한 요약

트랜잭션에서 처음 사용될 때 `SLOAD`, `*CALL`, `BALANCE`, `EXT*` 및 `SELFDESTRUCT`의 가스 비용을 증가시킵니다.

## 요약

`SLOAD` (`0x54`)의 가스 비용을 2100으로, `*CALL` 옵코드 계열 (`0xf1`, `f2`, `f4`, `fA`), `BALANCE` `0x31` 및 `EXT*` 옵코드 계열 (`0x3b`, `0x3c`, `0x3f`)을 2600으로 증가시킵니다. (i) 프리컴파일과 (ii) 동일한 트랜잭션에서 이미 접근된 주소 및 스토리지 슬롯은 제외되며, 감소된 가스 비용이 적용됩니다. 또한 `SSTORE` 계량 및 `SELFDESTRUCT`를 개편하여 해당 옵코드에 내재된 "사실상의 스토리지 로드"가 올바르게 가격 책정되도록 합니다.

## 동기

일반적으로 옵코드 가스 비용의 주요 기능은 해당 옵코드를 처리하는 데 필요한 시간의 추정치입니다. 목표는 가스 한도가 블록을 처리하는 데 필요한 시간의 한도에 해당하도록 하는 것입니다. 그러나 스토리지 접근 옵코드(`SLOAD`, `*CALL`, `BALANCE` 및 `EXT*` 옵코드)는 역사적으로 저평가되어 왔습니다. 2016년 상하이 DoS 공격에서 가장 심각한 클라이언트 버그가 수정된 후, 공격자가 사용한 더 지속적으로 성공적인 전략 중 하나는 단순히 많은 수의 계정에 접근하거나 호출하는 트랜잭션을 보내는 것이었습니다.

이를 완화하기 위해 가스 비용이 증가했지만, 최근 수치는 충분히 증가하지 않았음을 시사합니다. [https://arxiv.org/pdf/1909.07220.pdf](https://arxiv.org/pdf/1909.07220.pdf)를 인용하면:

> 이 문제 자체는 양성으로 보일 수 있지만, `EXTCODESIZE`는 클라이언트가 디스크에서 컨트랙트를 검색하도록 강제하여 IO 집약적인 트랜잭션을 발생시킵니다. 우리 하드웨어에서 이더리움 히스토리를 재생하는 동안 악성 트랜잭션은 평균 트랜잭션의 몇 밀리초에 비해 실행하는 데 약 20~80초가 걸렸습니다.

이 제안된 EIP는 이러한 옵코드의 비용을 ~3배 증가시켜 최악의 처리 시간을 ~7-27초로 줄입니다. 머클 트리를 통과하지 않고 스토리지를 직접 읽도록 클라이언트를 재설계하는 데이터베이스 레이아웃 개선은 이를 더 줄일 수 있지만, 이러한 기술은 완전히 배포되는 데 오랜 시간이 걸릴 수 있으며, 그러한 기술이 있더라도 스토리지 접근의 IO 오버헤드는 상당히 남아 있을 것입니다.

이 EIP의 부차적인 이점은 이더리움에서 [상태 비저장 증인 크기](https://ethereum-magicians.org/t/protocol-changes-to-bound-witness-size/3885)를 수용 가능하게 만드는 데 필요한 대부분의 작업도 수행한다는 것입니다. [바이너리 트라이로의 전환](https://ethresear.ch/t/binary-trie-format/7621)을 가정하면, 코드 크기를 제외한 이론적 최대 증인 크기("대부분의 작업"이지 "모든"이 아닌 이유)는 `(12500000 가스 한도) / (BALANCE당 700 가스) * (BALANCE당 800 증인 바이트) ~= 14.3M 바이트`에서 `12500000 / 2600 * 800 ~= 3.85M 바이트`로 감소합니다. 코드 접근에 대한 가격 책정은 코드 머클화가 구현될 때 변경될 수 있습니다.

## 사양

### 매개변수

| 상수 | 값 |
| - | - |
| `FORK_BLOCK` | 12244000 |
| `COLD_SLOAD_COST` | 2100 |
| `COLD_ACCOUNT_ACCESS_COST` | 2600 |
| `WARM_STORAGE_READ_COST` | 100 |

`block.number >= FORK_BLOCK`인 블록의 경우 다음 변경사항이 적용됩니다.

트랜잭션을 실행할 때 `accessed_addresses: Set[Address]` 집합과 `accessed_storage_keys: Set[Tuple[Address, Bytes32]]` 집합을 유지합니다.

이 집합들은 트랜잭션 컨텍스트 전체에 적용되며, 자기 파괴 목록 및 전역 `refund` 카운터와 같은 다른 트랜잭션 범위 구성과 동일하게 구현됩니다. 특히 범위가 되돌려지면 접근 목록은 해당 범위에 들어가기 전 상태로 있어야 합니다.

트랜잭션 실행이 시작될 때:
- `accessed_storage_keys`는 비어 있게 초기화되고,
- `accessed_addresses`는 다음을 포함하도록 초기화됩니다:
  - `tx.sender`, `tx.to` (또는 컨트랙트 생성 트랜잭션인 경우 생성되는 주소)
  - 모든 프리컴파일 집합.

### 스토리지 읽기 변경

주소가 (`EXTCODESIZE` (`0x3B`), `EXTCODECOPY` (`0x3C`), `EXTCODEHASH` (`0x3F`) 또는 `BALANCE` (`0x31`)) 옵코드의 대상이거나 (`CALL` (`0xF1`), `CALLCODE` (`0xF2`), `DELEGATECALL` (`0xF4`), `STATICCALL` (`0xFA`)) 옵코드의 대상인 경우 가스 비용은 다음과 같이 계산됩니다:

* 대상이 `accessed_addresses`에 없으면 `COLD_ACCOUNT_ACCESS_COST` 가스를 부과하고 주소를 `accessed_addresses`에 추가합니다.
* 그렇지 않으면 `WARM_STORAGE_READ_COST` 가스를 부과합니다.

모든 경우에 가스 비용은 부과되고 맵은 옵코드가 호출되는 시점에 업데이트됩니다.
`CREATE` 또는 `CREATE2` 옵코드가 호출되면 즉시(즉, 주소가 청구되지 않았는지 확인하는 검사가 수행되기 전에) 생성되는 주소를 `accessed_addresses`에 추가하지만, `CREATE`와 `CREATE2`의 가스 비용은 변경되지 않습니다.

`SLOAD`의 경우 `(address, storage_key)` 쌍(여기서 `address`는 스토리지가 읽히는 컨트랙트의 주소)이 아직 `accessed_storage_keys`에 없으면 `COLD_SLOAD_COST` 가스를 부과하고 쌍을 `accessed_storage_keys`에 추가합니다. 쌍이 이미 `accessed_storage_keys`에 있으면 `WARM_STORAGE_READ_COST` 가스를 부과합니다.

### SSTORE 변경

`SSTORE`를 호출할 때 `(address, storage_key)` 쌍이 `accessed_storage_keys`에 있는지 확인합니다. 없으면 추가로 `COLD_SLOAD_COST` 가스를 부과하고 쌍을 `accessed_storage_keys`에 추가합니다. 또한 [EIP-2200](./eip-2200.md)에 정의된 매개변수를 다음과 같이 수정합니다:

| 매개변수 | 이전 값 | 새 값 |
| - | - | - |
| `SLOAD_GAS` | 800 | `= WARM_STORAGE_READ_COST` |
| `SSTORE_RESET_GAS` | 5000 | `5000 - COLD_SLOAD_COST` |

EIP 2200에 정의된 다른 매개변수는 변경되지 않습니다.

### SELFDESTRUCT 변경

`SELFDESTRUCT`의 ETH 수신자가 `accessed_addresses`에 없으면(전송된 금액이 0이 아닌지와 관계없이), 기존 가스 비용 위에 추가로 `COLD_ACCOUNT_ACCESS_COST`를 부과하고 ETH 수신자를 집합에 추가합니다.

## 근거

### 옵코드 비용 vs 증인 데이터 바이트당 부과

증인 크기를 반영하도록 가스 비용을 변경하는 자연스러운 대안 경로는 증인 데이터 바이트당 부과하는 것입니다. 그러나 이는 구현하는 데 더 오랜 시간이 걸려 단기 보안 완화 제공 목표를 방해합니다. 또한 그 경로를 충실히 따르면 컨트랙트 코드에 접촉하는 트랜잭션에 대해 매우 높은 가스 비용이 발생합니다. 모든 24576 컨트랙트 코드 바이트에 대해 부과해야 하기 때문입니다; 이는 개발자에게 받아들일 수 없이 높은 부담이 될 것입니다. 개별 코드 청크에 접근하는 가스 비용을 적절히 계산하기 위해 [코드 머클화](https://medium.com/ewasm/evm-bytecode-merklization-2a8366ab0c90)를 기다리는 것이 좋습니다; 단기 DoS 방지 관점에서 디스크에서 24 kB에 접근하는 것은 디스크에서 32 바이트에 접근하는 것보다 훨씬 더 비싸지 않으므로 코드 크기에 대해 걱정할 필요가 없습니다.

### accessed_addresses / accessed_storage_keys 집합 추가

이미 접근한 계정과 스토리지 슬롯 집합이 추가되어 캐시할 수 있는 것(그리고 모든 성능 좋은 구현에서 이미 캐시되어 있는 것)에 대해 불필요하게 부과하는 것을 피합니다. 또한 자체 호출이나 프리컴파일 호출이 불필요하게 비용이 높은 현재의 바람직하지 않은 상황을 제거하고, 일부 스토리지 키를 미리 가져와 향후 실행이 여전히 예상 가스량을 사용할 수 있도록 하는 컨트랙트 파손 완화를 가능하게 합니다.

### SSTORE 가스 비용 변경

SSTORE에 대한 변경은 800 가스 비용으로 무작위로 선택된 제로 스토리지 슬롯을 "찌르는" DoS 공격 가능성을 피하기 위해 필요합니다. 이는 0에서 0으로 변경하지만 사실상 스토리지 로드가 필요합니다. `SSTORE_RESET_GAS` 감소는 SSTORE의 총 비용(이제 `COLD_SLOAD_COST`를 지불해야 함)이 변경되지 않도록 합니다. 또한 `SLOAD` 후 `SSTORE`를 수행하는 애플리케이션(예: `storage_variable += x`)은 _실제로 더 저렴해집니다_!

## 하위 호환성

이러한 가스 비용 증가는 고정 가스 비용에 의존하는 컨트랙트를 잠재적으로 손상시킬 수 있습니다. 자세한 내용과 총 위험이 낮을 것으로 예상되는 이유 및 원하는 경우 더 줄일 수 있는 방법에 대한 논의는 보안 고려사항 섹션을 참조하세요.

## 보안 고려사항

다른 가스 비용 증가 EIP와 마찬가지로 애플리케이션이 손상될 수 있는 세 가지 경우가 있습니다:

1. 컨트랙트의 서브콜에 대한 고정 가스 한도
2. 전체 가스 한도에 가깝게 소비하는 컨트랙트 호출에 의존하는 애플리케이션
3. ETH 전송 호출에 의해 피호출자에게 주어지는 2300 기본 한도

### 컨트랙트 파손 완화

위험을 보는 두 번째 방법은 완화를 탐색하는 것입니다. 우선, `accessed_addresses`와 `accessed_storage_keys` 맵의 존재(이 EIP에는 있고 EIP-1884에는 없음)는 이미 일부 경우를 복구 가능하게 합니다: 컨트랙트 A가 어떤 주소 B에 자금을 보내야 하는 경우, 해당 주소가 모든 소스에서 자금을 수락하지만 스토리지 의존 로그를 남기는 경우, 먼저 B에 별도의 호출을 보내 캐시로 가져온 다음 A를 호출하여 A에 의해 트리거된 B의 실행이 SLOAD당 100 가스만 부과되도록 복구할 수 있습니다. 이 사실이 모든 상황을 수정하지는 않지만 위험을 크게 줄입니다.

그러나 이 패턴의 사용성을 더 확장하는 방법이 있습니다. 한 가지 가능성은 주소와 스토리지 키를 입력으로 받아 접근할 모든 스토리지 슬롯을 미리 찔러 "구출" 시도하는 트랜잭션을 허용하는 `POKE` 프리컴파일을 추가하는 것입니다. 이것은 주소가 컨트랙트에서만 트랜잭션을 수락하는 경우에도 작동하며, 현재 가스 한도로 많은 다른 컨텍스트에서 작동합니다. 이것이 작동하지 않는 유일한 경우는 트랜잭션 호출이 EOA에서 곧바로 특정 컨트랙트로 가야 하고 그 다음 다른 컨트랙트를 서브콜하는 경우입니다.

또 다른 옵션은 [EIP-2930](./eip-2930.md)이며, 이는 `POKE`와 유사한 효과를 가지지만 더 일반적입니다: EOA -> 컨트랙트 -> 컨트랙트 경우에도 작동하며, 일반적으로 가스 비용 증가로 인한 모든 알려진 파손 사례에 대해 작동해야 합니다. 이 옵션은 더 복잡하지만, 다른 사용 사례(리제네시스, 계정 추상화, SSA 모두 접근 목록을 요구함)에 사용되는 접근 목록을 향한 디딤돌이라고 할 수 있습니다.

## 저작권
저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.
