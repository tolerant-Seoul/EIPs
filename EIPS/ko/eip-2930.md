---
eip: 2930
title: 선택적 접근 목록
description: 트랜잭션이 접근할 주소와 스토리지 키 목록을 포함하는 새로운 트랜잭션 유형을 추가합니다.
author: Vitalik Buterin (@vbuterin), Martin Swende (@holiman)
discussions-to: https://ethereum-magicians.org/t/eip-2930-optional-access-lists/4561
status: Final
type: Standards Track
category: Core
created: 2020-08-29
requires: 2718, 2929
lang: ko
original: ../eip-2930.md
---

## 간단한 요약

트랜잭션이 접근할 계획인 주소와 스토리지 키 목록인 접근 목록을 포함하는 트랜잭션 유형을 추가합니다. 목록 외부의 접근도 가능하지만 더 비용이 많이 듭니다.

## 요약

`0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])` 형식의 새로운 [EIP-2718](./eip-2718.md) 트랜잭션 유형을 도입합니다.

`accessList`는 주소와 스토리지 키의 목록을 지정합니다. 이러한 주소와 스토리지 키는 [EIP-2929](./eip-2929.md)에서 도입된 `accessed_addresses` 및 `accessed_storage_keys` 전역 집합에 추가됩니다. 가스 비용이 청구되지만, 목록 외부 접근 비용보다 할인된 가격입니다.

## 동기

이 EIP는 두 가지 기능을 수행합니다:

1. [EIP-2929](./eip-2929.md)가 도입한 컨트랙트 중단 위험을 완화합니다. 트랜잭션이 접근할 계획인 계정과 스토리지 슬롯을 사전에 지정하고 선불할 수 있기 때문입니다. 결과적으로 실제 실행에서 SLOAD 및 EXT* 옵코드는 100 가스만 소비합니다. 이는 해당 EIP로 인한 중단을 방지할 뿐만 아니라 EIP-1884로 인해 "멈춘" 컨트랙트도 "풀어줍니다".
2. 접근 목록 형식과 형식을 처리하는 로직을 도입합니다. 이 로직은 나중에 블록 전체 증인, ReGenesis에서의 사용, 시간이 지남에 따라 정적 상태 접근으로의 이동 등 여러 다른 목적으로 재사용될 수 있습니다.

## 사양

### 정의

**`TransactionType`** `1`. [EIP-2718](./eip-2718.md) 참조

**`ChainId`** 트랜잭션은 이 `chainID`를 가진 네트워크에서만 유효합니다.

**`YParity`** secp256k1 서명의 y 값의 패리티(짝수는 0, 홀수는 1).

### 매개변수

| 상수 | 값 |
| - | - |
| `FORK_BLOCK` | 12244000 |
| `ACCESS_LIST_STORAGE_KEY_COST` | 1900 |
| `ACCESS_LIST_ADDRESS_COST` | 2400 |

`FORK_BLOCK_NUMBER`부터 `TransactionType` `1`인 새로운 [EIP-2718](./eip-2718.md) 트랜잭션이 도입됩니다.

이 트랜잭션의 [EIP-2718](./eip-2718.md) `TransactionPayload`는 `rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS])`입니다.

이 트랜잭션의 `signatureYParity, signatureR, signatureS` 요소는 `keccak256(0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList]))`에 대한 secp256k1 서명을 나타냅니다.

이 트랜잭션의 [EIP-2718](./eip-2718.md) `ReceiptPayload`는 `rlp([status, cumulativeGasUsed, logsBloom, logs])`입니다.

트랜잭션이 유효하려면 `accessList`는 `[[{20 bytes}, [{32 bytes}...]]...]` 유형이어야 하며, 여기서 `...`는 "왼쪽의 것이 0개 이상"을 의미합니다. 예를 들어, 다음은 유효한 접근 목록입니다(모든 16진수 문자열은 실제로는 바이트 표현임):

```
[
    [
        "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae",
        [
            "0x0000000000000000000000000000000000000000000000000000000000000003",
            "0x0000000000000000000000000000000000000000000000000000000000000007"
        ]
    ],
    [
        "0xbb9bc244d798123fde783fcc1c72d3bb8c189413",
        []
    ]
]
```

실행 시작 시([EIP-2028](./eip-2028.md) 규칙에 따라 `21000 + 4 * zeroes + 16 * nonzeroes` 시작 가스가 청구되는 동시에), 접근 목록에 대한 추가 가스를 청구합니다: 주소당 `ACCESS_LIST_ADDRESS_COST` 가스 및 스토리지 키당 `ACCESS_LIST_STORAGE_KEY_COST` 가스. 예를 들어 위의 예시는 `ACCESS_LIST_ADDRESS_COST * 2 + ACCESS_LIST_STORAGE_KEY_COST * 2` 가스가 청구됩니다.

중복된 주소와 스토리지 키는 허용되지만, 여러 번 청구됩니다. 더 높은 가스 비용 외에 값을 여러 번 포함하는 것과 권장되는 단일 포함 사이에 실행 흐름이나 결과에 다른 차이는 없습니다.

주소와 스토리지 키는 즉시 `accessed_addresses` 및 `accessed_storage_keys` 전역 집합에 로드됩니다. 이는 다음 로직을 사용하여 수행할 수 있습니다(이는 RLP 디코딩된 접근 목록의 유효성 검사에 대한 코드 내 사양이기도 함):

```python
def process_access_list(access_list) -> Tuple[List[Set[Address], Set[Pair[Address, Bytes32]]], int]:
    accessed_addresses = set()
    accessed_storage_keys = set()
    gas_cost = 0
    assert isinstance(access_list, list)
    for item in access_list:
        assert isinstance(item, list) and len(item) == 2
        # 주소 유효성 검사 및 추가
        address = item[0]
        assert isinstance(address, bytes) and len(address) == 20
        accessed_addresses.add(address)
        gas_cost += ACCESS_LIST_ADDRESS_COST
        # 스토리지 키 유효성 검사 및 추가
        assert isinstance(item[1], list)
        for key in item[1]:
            assert isinstance(key, bytes) and len(key) == 32
            accessed_storage_keys.add((address, key))
            gas_cost += ACCESS_LIST_STORAGE_KEY_COST
    return (
        accessed_addresses,
        accessed_storage_keys,
        gas_cost
    )
```

접근 목록은 트랜잭션 데이터처럼 바이트당 수수료가 청구되지 않습니다. 위에서 설명한 항목당 비용은 접근 목록 데이터의 대역폭 비용과 트랜잭션 평가 시 해당 계정 및 스토리지 키에 접근하는 비용을 포함하기 위한 것입니다.

## 근거

### 접근 목록의 접근에 대해 더 적은 비용 청구

이는 트랜잭션이 가능한 한 접근 목록을 많이 사용하도록 장려하기 위한 것이며, 스토리지 읽기가 예측 가능할 때 트랜잭션 처리가 더 쉬워지기 때문입니다(클라이언트가 데이터베이스에서 데이터를 사전 로드하거나 트랜잭션이 수신될 때 증인을 요청하거나, 적어도 데이터를 병렬로 로드할 수 있기 때문).

### 중복 허용

이는 단순성을 최대화하기 위한 것으로, 무엇에 대해 중복을 방지할지에 대한 질문을 피합니다: 접근 목록의 두 주소/키 사이에서만, 접근 목록과 tx 발신자/수신자/새로 생성된 컨트랙트 사이에서, 기타 제한? 가스가 항목당 청구되므로 접근 목록에 값을 두 번 포함하는 것은 이득이 없고 비용만 있으므로 실제로 추가 체인 팽창으로 이어지지 않아야 합니다.

### 서명은 트랜잭션 데이터뿐만 아니라 트랜잭션 유형도 서명함

이는 트랜잭션이 다른 유형의 트랜잭션으로 "재해석"될 수 없도록 보장하기 위함입니다.

## 하위 호환성

이 EIP는 "예상치 못한" SLOAD 및 계정 접근을 수행하는 것을 더 가스 비용이 높게 만듭니다. 가스가 선불되어 고정 가스 로컬 호출에 영향을 미치지 않으므로 이전 가스 비용 증가가 위험할 수 있는 방식으로 컨트랙트를 중단시키지 않습니다. 그러나 스토리지 접근에 크게 의존하는 애플리케이션을 경제적으로 훨씬 덜 실행 가능하게 만듭니다.

## 보안 고려사항

### 접근 목록 생성

많은 상황에서 접근 목록을 실시간으로 구성하기 어렵고, 트랜잭션 생성과 서명 사이에 긴 시간 지연이 있거나 트랜잭션 생성기의 단순성이 높은 가치가 있는 환경(예: 하드웨어 지갑에서 둘 중 하나 또는 둘 다 적용될 수 있음)에서 이러한 어려움이 악화됩니다.

그러나 이 EIP는 접근 목록에 초기 10% 할인만 제안하므로 접근 목록 생성을 신경 쓰지 않고 단순한 트랜잭션만 만드는 것에 대한 비용이 거의 없습니다. 접근 목록 외부의 상태에 접근하는 비용은 도구가 개발되고 접근 목록 생성이 더 성숙해짐에 따라 향후 하드포크에서 시간이 지남에 따라 증가할 것으로 예상됩니다.

### 트랜잭션 크기 팽창

접근 목록이 사용됨에 따라 평균 블록 크기가 증가합니다. 그러나 접근 목록의 바이트당 비용은 스토리지 키의 경우 `1900 / 32 = 59.375`, 주소의 경우 `2400 / 20 = 120`으로, calldata보다 훨씬 비싸므로 최악의 경우 블록 크기는 증가하지 않습니다. 또한 평균 블록 크기 증가는 트랜잭션 수신 시 스토리지를 미리 가져오거나 블록 수신 시 스토리지를 병렬로 로드하는 기능에 의해 부분적으로 보상됩니다.

## 저작권
저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.
