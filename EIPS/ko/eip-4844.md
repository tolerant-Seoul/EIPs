---
eip: 4844
title: 샤드 블롭 트랜잭션
description: 샤드 블롭 트랜잭션은 간단하고 미래 호환성 있는 방식으로 이더리움의 데이터 가용성을 확장합니다.
author: Vitalik Buterin (@vbuterin), Dankrad Feist (@dankrad), Diederik Loerakker (@protolambda), George Kadianakis (@asn-d6), Matt Garnett (@lightclient), Mofi Taiwo (@Inphi), Ansgar Dietrichs (@adietrichs)
discussions-to: https://ethereum-magicians.org/t/eip-4844-shard-blob-transactions/8430
status: Final
type: Standards Track
category: Core
created: 2022-02-25
requires: 1559, 2718, 2930, 4895
lang: ko
original: ../eip-4844.md
---

## 요약

EVM 실행에서는 액세스할 수 없지만 커밋먼트는 액세스할 수 있는 대량의 데이터를 포함하는 "블롭 운반 트랜잭션"을 위한 새로운 트랜잭션 형식을 도입합니다.
이 형식은 완전 샤딩에서 사용될 형식과 완전히 호환되도록 설계되었습니다.

## 동기

롤업은 단기 및 중기적으로, 그리고 장기적으로도 이더리움을 위한 유일한 무신뢰 확장 솔루션입니다.
L1의 트랜잭션 수수료는 몇 달 동안 매우 높았고, 롤업으로의 생태계 전반적 이동을 촉진하는 데 필요한 모든 작업을 수행해야 하는 긴급성이 더 커졌습니다.
롤업은 많은 이더리움 사용자의 수수료를 크게 줄이고 있습니다: Optimism과 Arbitrum은 이더리움 기본 계층 자체보다 ~3-8배 낮은 수수료를 자주 제공하며,
더 나은 데이터 압축이 가능하고 서명 포함을 피할 수 있는 ZK 롤업은 기본 계층보다 ~40-100배 낮은 수수료를 제공합니다.

그러나 이러한 수수료도 많은 사용자에게는 너무 비쌉니다. 롤업만으로는 장기적으로 부적합하다는 것에 대한 장기적 해결책은 항상 데이터 샤딩이었으며,
이는 롤업이 사용할 수 있는 ~16 MB의 블록당 전용 데이터 공간을 체인에 추가합니다.
그러나 데이터 샤딩은 구현하고 배포하는 데 상당한 시간이 걸릴 것입니다.

이 EIP는 샤딩에서 사용될 _트랜잭션 형식_을 구현하지만 실제로 해당 트랜잭션을 샤딩하지는 않음으로써 그 시점까지의 임시 해결책을 제공합니다.
대신, 이 트랜잭션 형식의 데이터는 단순히 비콘 체인의 일부이며 모든 합의 노드에 의해 완전히 다운로드됩니다(비교적 짧은 지연 후에 삭제할 수 있음).
완전한 데이터 샤딩에 비해 이 EIP는 블록당 ~0.375 MB의 목표와 ~0.75 MB의 한도에 해당하는, 포함할 수 있는 이러한 트랜잭션 수에 대한 감소된 상한을 가집니다.

## 사양

### 매개변수

| 상수 | 값 |
| - | - |
| `BLOB_TX_TYPE` | `Bytes1(0x03)` |
| `BYTES_PER_FIELD_ELEMENT` | `32` |
| `FIELD_ELEMENTS_PER_BLOB` | `4096` |
| `BLS_MODULUS` | `52435875175126190479447740508185965837690552500527637822603658699938581184513` |
| `VERSIONED_HASH_VERSION_KZG` | `Bytes1(0x01)` |
| `POINT_EVALUATION_PRECOMPILE_ADDRESS` | `Bytes20(0x0A)` |
| `POINT_EVALUATION_PRECOMPILE_GAS` | `50000` |
| `MAX_BLOB_GAS_PER_BLOCK` | `786432` |
| `TARGET_BLOB_GAS_PER_BLOCK` | `393216` |
| `MIN_BASE_FEE_PER_BLOB_GAS` | `1` |
| `BLOB_BASE_FEE_UPDATE_FRACTION` | `3338477` |
| `GAS_PER_BLOB` | `2**17` |
| `HASH_OPCODE_BYTE` | `Bytes1(0x49)` |
| `HASH_OPCODE_GAS` | `3` |
| [`MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS`](https://github.com/ethereum/consensus-specs/blob/4de1d156c78b555421b72d6067c73b614ab55584/configs/mainnet.yaml#L148) | `4096` |

### 유형 별칭

| 유형 | 기본 유형 | 추가 검사 |
| - | - | - |
| `Blob` | `ByteVector[BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB]` | |
| `VersionedHash` | `Bytes32` | |
| `KZGCommitment` | `Bytes48` | IETF BLS 서명 "KeyValidate" 검사 수행, 단 항등점 허용 |
| `KZGProof` | `Bytes48` | `KZGCommitment`와 동일 |

### 암호화 헬퍼

이 제안 전반에 걸쳐 해당 [합의 4844 사양](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb)에 정의된 암호화 메서드와 클래스를 사용합니다.

특히 [`polynomial-commitments.md`](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb/polynomial-commitments.md)에서 다음 메서드를 사용합니다:

- [`verify_kzg_proof()`](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb/polynomial-commitments.md#verify_kzg_proof)
- [`verify_blob_kzg_proof_batch()`](https://github.com/ethereum/consensus-specs/blob/86fb82b221474cc89387fa6436806507b3849d88/specs/deneb/polynomial-commitments.md#verify_blob_kzg_proof_batch)

### 헬퍼

```python
def kzg_to_versioned_hash(commitment: KZGCommitment) -> VersionedHash:
    return VERSIONED_HASH_VERSION_KZG + sha256(commitment)[1:]
```

테일러 전개를 사용하여 `factor * e ** (numerator / denominator)`를 근사합니다:

```python
def fake_exponential(factor: int, numerator: int, denominator: int) -> int:
    i = 1
    output = 0
    numerator_accum = factor * denominator
    while numerator_accum > 0:
        output += numerator_accum
        numerator_accum = (numerator_accum * numerator) // (denominator * i)
        i += 1
    return output // denominator
```

### 블롭 트랜잭션

`TransactionType`이 `BLOB_TX_TYPE`이고 `TransactionPayload`가 다음 `TransactionPayloadBody`의 RLP 직렬화인 새로운 유형의 [EIP-2718](./eip-2718.md) 트랜잭션 "블롭 트랜잭션"을 도입합니다:

```
[chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, max_fee_per_blob_gas, blob_versioned_hashes, y_parity, r, s]
```

`chain_id`, `nonce`, `max_priority_fee_per_gas`, `max_fee_per_gas`, `gas_limit`, `value`, `data`, `access_list` 필드는 [EIP-1559](./eip-1559.md)와 동일한 의미를 따릅니다.

`to` 필드는 `nil`이어서는 안 되며 **반드시** 항상 20바이트 주소를 나타내야 한다는 점에서 의미가 약간 다릅니다. 이는 블롭 트랜잭션이 생성 트랜잭션 형태를 가질 수 없음을 의미합니다.

`max_fee_per_blob_gas` 필드는 `uint256`이고 `blob_versioned_hashes` 필드는 `kzg_to_versioned_hash`의 해시 출력 목록을 나타냅니다.

이 트랜잭션의 [EIP-2718](./eip-2718.md) `ReceiptPayload`는 `rlp([status, cumulative_transaction_gas_used, logs_bloom, logs])`입니다.

#### 서명

서명 값 `y_parity`, `r`, `s`는 다음 다이제스트에 대한 secp256k1 서명을 구성하여 계산됩니다:

`keccak256(BLOB_TX_TYPE || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, to, value, data, access_list, max_fee_per_blob_gas, blob_versioned_hashes]))`.

### 헤더 확장

현재 헤더 인코딩은 두 개의 새로운 64비트 부호 없는 정수 필드로 확장됩니다:

- `blob_gas_used`는 블록 내 트랜잭션에 의해 소비된 총 블롭 가스 양입니다.
- `excess_blob_gas`는 블록 이전에 목표를 초과하여 소비된 블롭 가스의 누적 합계입니다. 목표 초과 블롭 가스 소비가 있는 블록은 이 값을 증가시키고, 목표 미만 블롭 가스 소비가 있는 블록은 감소시킵니다(0에서 제한됨).

결과적인 헤더의 RLP 인코딩은 다음과 같습니다:

```
rlp([
    parent_hash,
    0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347, # ommers 해시
    coinbase,
    state_root,
    txs_root,
    receipts_root,
    logs_bloom,
    0, # difficulty
    number,
    gas_limit,
    gas_used,
    timestamp,
    extradata,
    prev_randao,
    0x0000000000000000, # nonce
    base_fee_per_gas,
    withdrawals_root,
    blob_gas_used,
    excess_blob_gas,
])
```

`excess_blob_gas`의 값은 부모 헤더를 사용하여 계산할 수 있습니다.

```python
def calc_excess_blob_gas(parent: Header) -> int:
    if parent.excess_blob_gas + parent.blob_gas_used < TARGET_BLOB_GAS_PER_BLOCK:
        return 0
    else:
        return parent.excess_blob_gas + parent.blob_gas_used - TARGET_BLOB_GAS_PER_BLOCK
```

포크 후 첫 번째 블록의 경우 `parent.blob_gas_used`와 `parent.excess_blob_gas`는 모두 `0`으로 평가됩니다.

### 가스 회계

블롭 가스를 새로운 유형의 가스로 도입합니다. 이는 일반 가스와 독립적이며 EIP-1559와 유사한 자체 타겟팅 규칙을 따릅니다.
블롭 가스 기본 수수료를 계산하는 데 필요한 지속적인 데이터를 저장하기 위해 `excess_blob_gas` 헤더 필드를 사용합니다. 현재 블롭만 블롭 가스로 가격이 책정됩니다.

```python
def calc_blob_fee(header: Header, tx: Transaction) -> int:
    return get_total_blob_gas(tx) * get_base_fee_per_blob_gas(header)

def get_total_blob_gas(tx: Transaction) -> int:
    return GAS_PER_BLOB * len(tx.blob_versioned_hashes)

def get_base_fee_per_blob_gas(header: Header) -> int:
    return fake_exponential(
        MIN_BASE_FEE_PER_BLOB_GAS,
        header.excess_blob_gas,
        BLOB_BASE_FEE_UPDATE_FRACTION
    )
```

블록 유효성 조건은 블롭 가스 검사를 포함하도록 수정됩니다(아래 [실행 계층 검증](#실행-계층-검증) 섹션 참조).

`calc_blob_fee`를 통해 계산된 실제 `blob_fee`는 트랜잭션 실행 전에 발신자 잔액에서 차감되어 소각되며, 트랜잭션 실패 시 환불되지 않습니다.

### 버전 해시를 가져오는 옵코드

스택 상단에서 `index`를 빅엔디안 `uint256`으로 읽고, `index < len(tx.blob_versioned_hashes)`이면 스택에서 `tx.blob_versioned_hashes[index]`로 대체하고, 그렇지 않으면 0으로 채워진 `bytes32` 값으로 대체하는 명령어 `BLOBHASH`(옵코드 `HASH_OPCODE_BYTE`)를 추가합니다.
이 옵코드의 가스 비용은 `HASH_OPCODE_GAS`입니다.

### 포인트 평가 프리컴파일

블롭(커밋먼트로 표현됨)이 주어진 지점에서 주어진 값으로 평가된다고 주장하는 KZG 증명을 검증하는 프리컴파일을 `POINT_EVALUATION_PRECOMPILE_ADDRESS`에 추가합니다.

프리컴파일 비용은 `POINT_EVALUATION_PRECOMPILE_GAS`이며 다음 로직을 실행합니다:

```python
def point_evaluation_precompile(input: Bytes) -> Bytes:
    """
    다항식 p(x)에 해당하는 커밋먼트와 KZG 증명이 주어졌을 때 p(z) = y를 검증합니다.
    또한 제공된 커밋먼트가 제공된 versioned_hash와 일치하는지 검증합니다.
    """
    # 데이터는 다음과 같이 인코딩됩니다: versioned_hash | z | y | commitment | proof | (z와 y는 패딩된 32바이트 빅엔디안 값)
    assert len(input) == 192
    versioned_hash = input[:32]
    z = input[32:64]
    y = input[64:96]
    commitment = input[96:144]
    proof = input[144:192]

    # 커밋먼트가 versioned_hash와 일치하는지 검증
    assert kzg_to_versioned_hash(commitment) == versioned_hash

    # 빅엔디안 형식의 z와 y로 KZG 증명 검증
    assert verify_kzg_proof(commitment, z, y, proof)

    # FIELD_ELEMENTS_PER_BLOB과 BLS_MODULUS를 패딩된 32바이트 빅엔디안 값으로 반환
    return Bytes(U256(FIELD_ELEMENTS_PER_BLOB).to_be_bytes32() + U256(BLS_MODULUS).to_be_bytes32())
```

프리컴파일은 비정규 필드 요소를 **반드시** 거부**해야 합니다(MUST)**(즉, 제공된 필드 요소는 **반드시** `BLS_MODULUS`보다 엄격하게 작아야 합니다).

### 합의 계층 검증

합의 계층에서 블롭은 참조되지만 비콘 블록 바디에 완전히 인코딩되지 않습니다.
전체 내용을 바디에 포함하는 대신, 블롭은 "사이드카"로 별도로 전파됩니다.

이 "사이드카" 설계는 `is_data_available()`을 블랙박스로 만들어 추가 데이터 증가를 위한 전방 호환성을 제공합니다:
완전 샤딩에서 `is_data_available()`은 데이터 가용성 샘플링(DAS)으로 대체될 수 있어 네트워크의 모든 비콘 노드에서 모든 블롭을 다운로드하는 것을 피할 수 있습니다.

합의 계층은 데이터 가용성을 위해 블롭을 유지하는 역할을 담당하며, 실행 계층은 그렇지 않습니다.

`ethereum/consensus-specs` 저장소는 이 EIP에 포함된 다음 합의 계층 변경사항을 정의합니다:

- 비콘 체인: 업데이트된 비콘 블록을 처리하고 블롭을 사용할 수 있는지 확인합니다.
- P2P 네트워크: 업데이트된 비콘 블록 유형과 새로운 블롭 사이드카를 가십하고 동기화합니다.
- 정직한 검증자: 블롭이 있는 비콘 블록을 생성하고; 관련 블롭 사이드카를 서명하고 게시합니다.

### 실행 계층 검증

실행 계층에서 블록 유효성 조건은 다음과 같이 확장됩니다:

```python
def validate_block(block: Block) -> None:
    ...

    # excess blob gas가 올바르게 업데이트되었는지 확인
    assert block.header.excess_blob_gas == calc_excess_blob_gas(block.parent.header)

    blob_gas_used = 0

    for tx in block.transactions:
        ...

        # 충분한 잔액 검사 수정
        max_total_fee = tx.gas * tx.max_fee_per_gas
        if get_tx_type(tx) == BLOB_TX_TYPE:
            max_total_fee += get_total_blob_gas(tx) * tx.max_fee_per_blob_gas
        assert signer(tx).balance >= max_total_fee

        ...

        # 블롭 tx에 특화된 유효성 로직 추가
        if get_tx_type(tx) == BLOB_TX_TYPE:
            # 최소 하나의 블롭이 있어야 함
            assert len(tx.blob_versioned_hashes) > 0

            # 모든 버전된 블롭 해시는 VERSIONED_HASH_VERSION_KZG로 시작해야 함
            for h in tx.blob_versioned_hashes:
                assert h[0] == VERSIONED_HASH_VERSION_KZG

            # 사용자가 최소한 현재 블롭 기본 수수료를 지불할 의향이 있는지 확인
            assert tx.max_fee_per_blob_gas >= get_base_fee_per_blob_gas(block.header)

            # 블록에서 사용된 총 블롭 가스 추적
            blob_gas_used += get_total_blob_gas(tx)

    # 총 블롭 가스 사용량이 최대 한도 이하인지 확인
    assert blob_gas_used <= MAX_BLOB_GAS_PER_BLOCK

    # blob_gas_used가 헤더와 일치하는지 확인
    assert block.header.blob_gas_used == blob_gas_used
```

### 네트워킹

블롭 트랜잭션은 두 가지 네트워크 표현을 가집니다. 트랜잭션 가십 응답(`PooledTransactions`) 중에 블롭 트랜잭션의 EIP-2718 `TransactionPayload`는 다음과 같이 래핑됩니다:

```
rlp([tx_payload_body, blobs, commitments, proofs])
```

각 요소는 다음과 같이 정의됩니다:

- `tx_payload_body` - 표준 EIP-2718 [블롭 트랜잭션](#블롭-트랜잭션)의 `TransactionPayloadBody`
- `blobs` - `Blob` 항목 목록
- `commitments` - 해당 `blobs`의 `KZGCommitment` 목록
- `proofs` - 해당 `blobs`와 `commitments`의 `KZGProof` 목록

노드는 `tx_payload_body`를 검증하고 래핑된 데이터를 이에 대해 **반드시** 검증**해야 합니다(MUST)**. 이를 위해 다음을 확인합니다:

- `tx_payload_body.blob_versioned_hashes`, `blobs`, `commitments`, `proofs`의 수가 동일해야 합니다.
- KZG `commitments`가 버전된 해시로 해시되어야 합니다. 즉, `kzg_to_versioned_hash(commitments[i]) == tx_payload_body.blob_versioned_hashes[i]`
- KZG `commitments`가 해당 `blobs` 및 `proofs`와 일치해야 합니다. (참고: 이는 각 블롭에 대한 커밋먼트와 블롭 데이터에서 파생된 지점에서의 무작위 평가에 대한 증명과 함께 `verify_blob_kzg_proof_batch`를 사용하여 최적화할 수 있습니다)

바디 검색 응답(`BlockBodies`)의 경우, 표준 EIP-2718 블롭 트랜잭션 `TransactionPayload`가 사용됩니다.

노드는 블롭 트랜잭션을 피어에게 자동으로 브로드캐스트**해서는 안 됩니다(MUST NOT)**.
대신, 해당 트랜잭션은 `NewPooledTransactionHashes` 메시지를 사용해서만 공지되며, 그런 다음 `GetPooledTransactions`를 통해 수동으로 요청할 수 있습니다.

## 근거

### 샤딩으로 가는 길

이 EIP는 최종 샤딩 사양에서 존재할 것으로 예상되는 것과 동일한 형식으로 블롭 트랜잭션을 도입합니다.
이는 롤업이 처음에 슬롯당 0.375 MB까지 확장할 수 있도록 함으로써 일시적이지만 상당한 확장 완화를 제공하며,
이 시스템의 사용이 제한된 동안 수수료가 매우 낮을 수 있도록 별도의 수수료 시장을 제공합니다.

롤업 확장 임시 해결책의 핵심 목표는 롤업이 이 완화를 활용하기 위해 추가 개발 부담을 지우지 않고 일시적인 확장 완화를 제공하는 것입니다.
오늘날 롤업은 콜데이터를 사용합니다. 미래에 롤업은 샤딩된 데이터(또한 "블롭"이라고 함)를 사용할 수밖에 없습니다.
왜냐하면 샤딩된 데이터가 훨씬 저렴할 것이기 때문입니다.
따라서 롤업은 데이터를 처리하는 방식에 대한 대규모 업그레이드를 적어도 한 번은 피할 수 없습니다.
하지만 우리가 _할 수 있는_ 것은 롤업이 _한 번만_ 업그레이드하면 되도록 보장하는 것입니다.
이는 즉시 임시 해결책에 대해 정확히 두 가지 가능성이 있음을 의미합니다: (i) 기존 콜데이터 비용 절감,
(ii) 샤딩된 데이터에 사용될 형식을 앞당기되 아직 실제로 샤딩하지는 않는 것.
이전 EIP는 모두 범주 (i)의 해결책이었습니다; 이 EIP는 범주 (ii)의 해결책입니다.

이 EIP를 설계하는 주요 트레이드오프는 지금 더 많이 구현하느냐 나중에 더 많이 구현해야 하느냐입니다:
완전 샤딩으로 가는 길에 작업의 25%를 구현하느냐, 50%를 구현하느냐, 75%를 구현하느냐?

이 EIP에서 이미 완료된 작업에는 다음이 포함됩니다:

- "완전 샤딩"에 존재해야 하는 것과 정확히 같은 형식의 새로운 트랜잭션 유형
- 완전 샤딩에 필요한 _모든_ 실행 계층 로직
- 완전 샤딩에 필요한 _모든_ 실행/합의 교차 검증 로직
- `BeaconBlock` 검증과 데이터 가용성 샘플링 블롭 간의 계층 분리
- 완전 샤딩에 필요한 대부분의 `BeaconBlock` 로직
- 블롭에 대한 자체 조정 독립 기본 수수료

완전 샤딩을 달성하기 위해 남은 작업에는 다음이 포함됩니다:

- 2D 샘플링을 허용하기 위한 합의 계층의 `commitments`의 저차 확장
- 데이터 가용성 샘플링의 실제 구현
- PBS(제안자/빌더 분리), 개별 검증자가 한 슬롯에서 32 MB의 데이터를 처리하지 않아도 되도록
- 각 블록의 샤딩된 데이터의 특정 부분을 각 검증자가 검증하도록 하는 보관 증명 또는 유사한 프로토콜 내 요구 사항

이 EIP는 또한 장기적인 프로토콜 정리를 위한 발판을 마련합니다. 예를 들어, (더 깔끔한) 가스 기본 수수료 업데이트 규칙을 기본 기본 수수료 계산에 적용할 수 있습니다.

### 롤업이 작동하는 방식

롤업 블록 데이터를 트랜잭션 콜데이터에 넣는 대신, 롤업은 롤업 블록 제출자가 데이터를 블롭에 넣을 것으로 예상합니다. 이는 가용성을 보장하지만(롤업에 필요한 것) 콜데이터보다 훨씬 저렴합니다.
롤업은 데이터가 한 번, 정직한 행위자가 롤업 상태를 구성할 수 있을 만큼 충분히 길게 사용 가능해야 하지만 영원히는 아닙니다.

낙관적 롤업은 사기 증명이 제출될 때만 실제로 기본 데이터를 제공하면 됩니다.
사기 증명은 전환을 더 작은 단계로 검증할 수 있으며, 콜데이터를 통해 한 번에 블롭의 몇 가지 값만 로드합니다.
각 값에 대해 KZG 증명을 제공하고 포인트 평가 프리컴파일을 사용하여 이전에 제출된 버전된 해시에 대해 값을 검증한 다음,
오늘날 수행되는 것처럼 해당 데이터에 대해 사기 증명 검증을 수행합니다.

ZK 롤업은 트랜잭션 또는 상태 델타 데이터에 대해 두 가지 커밋먼트를 제공합니다:
블롭 커밋먼트(프로토콜이 사용 가능한 데이터를 가리키도록 보장함)와 롤업이 내부적으로 사용하는 증명 시스템을 사용하는 ZK 롤업 자체 커밋먼트.
두 커밋먼트가 동일한 데이터를 참조한다는 것을 증명하기 위해 포인트 평가 프리컴파일을 사용하여 동등성 증명 프로토콜을 사용합니다.

### 버전된 해시 및 프리컴파일 반환 데이터

미래 변경사항과의 전방 호환성을 보장하기 위해 실행 계층에서 블롭에 대한 참조로 (커밋먼트 대신) 버전된 해시를 사용합니다.
예를 들어, 양자 안전성을 위해 머클 트리 + STARK로 전환해야 하는 경우 새 버전을 추가하여
포인트 평가 프리컴파일이 새 형식과 작동할 수 있도록 합니다.
롤업은 작동 방식에 대한 EVM 수준 변경을 할 필요가 없습니다;
시퀀서는 적절한 시점에 새 트랜잭션 유형을 사용하도록 전환하기만 하면 됩니다.

그러나 포인트 평가는 유한 필드 내에서 발생하며, 필드 모듈러스가 알려진 경우에만 잘 정의됩니다. 스마트 컨트랙트는 커밋먼트 버전을 모듈러스에 매핑하는 테이블을 포함할 수 있지만, 이는 스마트 컨트랙트가 아직 알려지지 않은 모듈러스에 대한 미래 업그레이드를 고려할 수 없게 합니다. EVM 내에서 모듈러스에 액세스할 수 있게 함으로써 스마트 컨트랙트는 업그레이드 없이 미래 커밋먼트와 증명을 사용할 수 있도록 구축될 수 있습니다.

또 다른 프리컴파일을 추가하지 않기 위해 모듈러스와 다항식 차수를 포인트 평가 프리컴파일에서 직접 반환합니다. 그런 다음 호출자가 사용할 수 있습니다. 또한 호출자가 추가 비용 없이 반환 값의 이 부분을 무시할 수 있으므로 "무료"입니다 -- 가까운 미래에 업그레이드 가능하게 유지되는 시스템은 현재 이 경로를 사용할 가능성이 높습니다.

### 블롭당 기본 수수료 업데이트 규칙

블롭당 기본 수수료 업데이트 규칙은 `base_fee_per_blob_gas = MIN_BASE_FEE_PER_BLOB_GAS * e**(excess_blob_gas / BLOB_BASE_FEE_UPDATE_FRACTION)` 공식을 근사하도록 의도되었습니다.
여기서 `excess_blob_gas`는 체인이 "목표" 수량(블록당 `TARGET_BLOB_GAS_PER_BLOCK`)에 비해 소비한 총 "추가" 블롭 가스 양입니다.
EIP-1559와 마찬가지로 자체 교정 공식입니다: 초과가 높아지면 `base_fee_per_blob_gas`가 기하급수적으로 증가하여 사용량을 줄이고 결국 초과를 다시 낮춥니다.

블록별 동작은 대략 다음과 같습니다.
블록 `N`이 `X` 블롭 가스를 소비하면 블록 `N+1`에서 `excess_blob_gas`가 `X - TARGET_BLOB_GAS_PER_BLOCK`만큼 증가하고,
따라서 블록 `N+1`의 `base_fee_per_blob_gas`가 `e**((X - TARGET_BLOB_GAS_PER_BLOCK) / BLOB_BASE_FEE_UPDATE_FRACTION)` 배만큼 증가합니다.
따라서 기존 EIP-1559와 유사한 효과를 가지지만, 동일한 총 사용량에 대해 분포와 관계없이 동일한 방식으로 응답한다는 점에서 더 "안정적"입니다.

`BLOB_BASE_FEE_UPDATE_FRACTION` 매개변수는 블롭당 기본 수수료의 최대 변화율을 제어합니다. 블록당 최대 변화율 `e**(TARGET_BLOB_GAS_PER_BLOCK / BLOB_BASE_FEE_UPDATE_FRACTION) ≈ 1.125`를 목표로 선택되었습니다.

### 처리량

`TARGET_BLOB_GAS_PER_BLOCK`과 `MAX_BLOB_GAS_PER_BLOCK`의 값은 블록당 3개의 블롭(0.375 MB) 목표와 최대 6개의 블롭(0.75 MB)에 해당하도록 선택되었습니다. 이러한 작은 초기 한도는 이 EIP로 인해 네트워크에 가해지는 부담을 최소화하기 위한 것이며, 네트워크가 더 큰 블록에서 신뢰성을 입증함에 따라 향후 업그레이드에서 증가할 것으로 예상됩니다.

## 하위 호환성

### 블롭 비접근성

이 EIP는 두 버전 간에 단방향 변환만 가능한 별도의 멤풀 버전과 실행 페이로드 버전을 가진 트랜잭션 유형을 도입합니다. 블롭은 네트워크 표현에 있고 합의 표현에는 없습니다;
대신 비콘 블록과 결합됩니다. 이는 이제 web3 API에서 액세스할 수 없는 트랜잭션의 일부가 있음을 의미합니다.

### 멤풀 문제

블롭 트랜잭션은 멤풀 계층에서 큰 데이터 크기를 가지며, 이는 멤풀 DoS 위험을 초래합니다.
하지만 이것은 대량의 콜데이터가 있는 트랜잭션에도 적용되므로 전례 없는 것은 아닙니다.

블롭 트랜잭션에 대한 공지만 브로드캐스트함으로써 수신 노드는 수신할 트랜잭션의 종류와 수를 제어할 수 있어
처리량을 허용 가능한 수준으로 조절할 수 있습니다.
[EIP-5793](./eip-5793.md)은 트랜잭션 유형과 크기를 포함하도록 `NewPooledTransactionHashes` 공지 메시지를 확장하여 노드에 더 세밀한 제어를 제공합니다.

또한 멤풀 트랜잭션 교체 규칙에 블롭당 1.1배 기본 수수료 범프 요구 사항을 포함하는 것을 권장합니다.

## 테스트 케이스

이 EIP의 실행 계층 테스트 케이스는 `ethereum/execution-spec-tests` 저장소의 [`eip4844_blobs`](https://github.com/ethereum/execution-spec-tests/tree/1983444bbe1a471886ef7c0e82253ffe2a4053e1/tests/cancun/eip4844_blobs)에서 찾을 수 있습니다. 합의 계층 테스트 케이스는 [여기](https://github.com/ethereum/consensus-specs/tree/2297c09b7e457a13f7b2261a28cb45777be82f83/tests/core/pyspec/eth2spec/test/deneb)에서 찾을 수 있습니다.

## 보안 고려사항

이 EIP는 비콘 블록당 대역폭 요구 사항을 최대 ~0.75 MB 증가시킵니다.
이는 오늘날 블록의 이론적 최대 크기(30M 가스 / 콜데이터 바이트당 16 가스 = 1.875M 바이트)보다 40% 더 크므로 최악의 경우 대역폭을 크게 증가시키지는 않습니다.
병합 후 블록 시간은 예측 불가능한 포아송 분포가 아닌 정적이므로 큰 블록이 전파될 수 있는 보장된 기간을 제공합니다.

이 EIP의 _지속적인_ 부하는 콜데이터 비용을 줄이는 대안보다 훨씬 낮습니다. 콜데이터가 제한되더라도,
블롭은 실행 페이로드만큼 오래 저장될 것으로 예상되지 않기 때문입니다.
이를 통해 이러한 블롭이 최소 특정 기간 동안 유지되어야 한다는 정책을 구현할 수 있습니다. 선택된 특정 값은 `MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS` 에포크로, 약 18일입니다.
이는 제안되었지만 아직 구현되지 않은 실행 페이로드 기록의 1년 순환 시간에 비해 훨씬 짧은 지연입니다.

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.
