---
eip: 6963
title: 다중 주입 프로바이더 발견
description: 주입된 지갑 프로바이더를 발표하기 위해 window 이벤트 사용
author: Pedro Gomes (@pedrouid), Kosala Hemachandra (@kvhnuke), Richard Moore (@ricmoo), Gregory Markou (@GregTheGreek), Kyle Den Hartog (@kdenhartog), Glitch (@glitch-txs), Jake Moxey (@jxom), Pierre Bertet (@bpierre), Darryl Yeo (@darrylyeo), Yaroslav Sergievsky (@everdimension)
discussions-to: https://ethereum-magicians.org/t/eip-6963-multi-injected-provider-interface-aka-mipi/14076
status: Final
type: Standards Track
category: Interface
created: 2023-05-01
requires: 1193
lang: ko
original: ../eip-6963.md
---

## 요약

JavaScript의 `window` 이벤트를 사용하여 웹 페이지에서 여러 주입된 지갑 프로바이더를 발견하는 것을 지원하는 [EIP-1193](./eip-1193.md) 프로바이더를 위한 `window.ethereum`에 대한 대안적 발견 메커니즘입니다.

## 동기

현재 브라우저 확장 프로그램을 제공하는 지갑 프로바이더는 이더리움 프로바이더([EIP-1193](./eip-1193.md))를 동일한 window 객체 `window.ethereum`에 주입해야 합니다. 그러나 이는 둘 이상의 브라우저 확장 프로그램을 설치할 수 있는 사용자에게 충돌을 일으킵니다.

브라우저 확장 프로그램은 예측할 수 없고 불안정한 순서로 웹 페이지에 로드되므로, 사용자가 `window.ethereum` 객체 아래에 이더리움 인터페이스를 노출할 지갑 프로바이더를 제어할 수 없는 경쟁 조건이 발생합니다. 대신 마지막으로 로드되는 지갑이 일반적으로 승리합니다.

이는 사용자 경험 저하뿐만 아니라 사용자가 한 번에 하나의 브라우저 확장 프로그램만 설치해야 하므로 새로운 브라우저 확장 프로그램의 진입 장벽을 높입니다.

일부 브라우저 확장 프로그램은 동일한 `window.ethereum` 객체를 덮어쓰기 위해 주입을 지연시켜 이 문제에 대응하려고 하는데, 이는 지갑 프로바이더 간의 불공정한 경쟁과 상호 운용성 부족을 초래합니다.

이 제안에서는 여러 지갑 프로바이더의 상호 운용성을 최적화하는 데 중점을 둔 솔루션을 제시합니다. 이 솔루션은 새로운 지갑 프로바이더의 진입 장벽을 줄여 더 공정한 경쟁을 촉진하고 이더리움 네트워크에서 사용자 경험을 향상시키는 것을 목표로 합니다.

이것은 이더리움 라이브러리와 브라우저 확장 프로그램이 제공하는 주입된 스크립트 사이에 양방향 통신 프로토콜을 제공하는 일련의 window 이벤트를 도입하여 사용자가 선택한 지갑을 선택할 수 있도록 함으로써 달성됩니다.

## 사양

이 문서에서 "반드시(MUST)", "반드시 아니다(MUST NOT)", "필수(REQUIRED)", "해야 한다(SHALL)", "해서는 안 된다(SHALL NOT)", "해야 한다(SHOULD)", "해서는 안 된다(SHOULD NOT)", "권장(RECOMMENDED)", "할 수 있다(MAY)", "선택적(OPTIONAL)"이라는 핵심 단어는 [RFC-2119]에 설명된 대로 해석됩니다.

### 정의

지갑 프로바이더(Wallet Provider): 키를 관리하고 이더리움과의 트랜잭션을 용이하게 하는 사용자 에이전트.

탈중앙화 애플리케이션(DApp): 지갑을 통해 웹 페이지에 노출되는 하나 이상의 Web3 플랫폼 API에 의존하는 웹 페이지.

프로바이더 발견 라이브러리(Provider Discovery Library): DApp이 지갑과 상호 작용하는 것을 돕는 라이브러리 또는 소프트웨어.

### 프로바이더 정보

각 지갑 프로바이더는 다음 인터페이스 `EIP6963ProviderInfo`로 발표됩니다. `EIP6963ProviderInfo`의 값은 **반드시** `EIP6963ProviderInfo` 객체 내에 포함되어야 합니다(MUST). `EIP6963ProviderInfo`는 객체 내에 추가 확장 가능한 속성을 포함**할 수 있습니다(MAY)**. DApp이 추가 속성을 인식하지 못하면 무시**해야 합니다(SHOULD)**.

- **`uuid`** - 페이지 수명 동안 아래 정의된 일치하는 속성을 가진 서로 다른 [EIP-1193](./eip-1193.md) 프로바이더 세션을 고유하게 구별하기 위해 **반드시** ([UUIDv4][RFC-4122] 준수) 전역적으로 고유한 지갑 프로바이더 식별자여야 합니다(MUST). [UUIDv4][RFC-4122]가 제공하는 암호학적 고유성은 두 개의 독립적인 `EIP6963ProviderInfo` 객체를 개별적으로 식별할 수 있음을 보장합니다.
- **`name`** - DApp에서 사용자에게 표시될 지갑 프로바이더의 사람이 읽을 수 있는 로컬 별칭. (예: `Example Wallet Extension` 또는 `Awesome Example Wallet`)
- **`icon`** - 이미지를 가리키는 [URI][RFC-3986]. 이미지는 최소 해상도 96x96px의 정사각형**이어야 합니다(SHOULD)**. 이 속성의 추가 요구 사항은 아래 [이미지/아이콘](#이미지아이콘) 섹션을 참조하세요.
- **`rdns`** - 지갑은 `com.example.subdomain`과 같이 역순 구문 순서로 도메인 이름 시스템의 도메인 이름인 `rdns` 속성을 **반드시** 제공해야 합니다(MUST). 사용할 도메인 이름은 지갑이 결정하지만, 일반적으로 식별자는 지갑 개발 전반에 걸쳐 동일하게 유지될 것으로 예상됩니다. 브라우저의 사용자 에이전트 문자열과 유사하게, 제공된 값이 알 수 없거나, 유효하지 않거나, 올바르지 않거나, 다른 지갑을 모방하려고 시도할 수 있는 경우가 있다는 점도 주목할 가치가 있습니다. 따라서 DApp은 DApp 기능에 대한 최소한의 저하로 이러한 실패 사례를 처리할 수 있어야 **합니다(SHOULD)**.

```typescript
/**
 * 지갑을 표시하는 데 필요한 자산을 나타냅니다
 */
interface EIP6963ProviderInfo {
  uuid: string;
  name: string;
  icon: string;
  rdns: string;
}
```

#### 이미지/아이콘

URI 인코딩 이미지는 아이콘을 가져오고 렌더링하기 위한 여러 프로토콜에 대한 유연성을 제공하기 위해 선택되었습니다. 예를 들어:

```sh
# svg (data uri)
data:image/svg+xml,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 32 32"><circle fill="red" cx="16" cy="16" r="12"/></svg>
# png (data uri)
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==
```

`icon` 문자열은 [RFC-2397]에 정의된 데이터 URI**여야 합니다(MUST)**. 이미지는 최소 해상도 96x96px의 정사각형**이어야 합니다(SHOULD)**. 이미지 형식은 DApp에서 이미지를 쉽게 렌더링할 수 있도록 PNG, WebP 또는 SVG와 같은 무손실 또는 벡터 기반 형식을 **권장합니다(RECOMMENDED)**. SVG 이미지는 JavaScript를 실행할 수 있으므로 애플리케이션 및 라이브러리는 신뢰할 수 없는 JavaScript 실행이 발생하지 않도록 `<img>` 태그를 사용하여 SVG 이미지를 **반드시** 렌더링해야 합니다(MUST).

#### RDNS

**`rdns`** (Reverse-DNS) 속성은 DApp이 세션 간에 안정적으로 의존할 수 있는 식별자를 제공하는 역할을 합니다. 역순 도메인 이름 표기법은 네임스페이스 충돌을 방지하기 위해 선택되었습니다.
역순 DNS 규칙은 값이 프로바이더가 제어하는 역순 DNS 도메인 이름으로 시작해야 함을 의미합니다. 도메인 이름 뒤에는 하위 도메인이나 제품 이름이 와야 합니다. 예: `com.example.MyBrowserWallet`.

- `rdns` 값은 유효한 [RFC-1034] 도메인 이름**이어야 합니다(MUST)**;
- `rdns` 값의 DNS 부분은 프로바이더가 제어하는 활성 도메인**이어야 합니다(SHOULD)**;
- DApp은 역순 DNS 규칙을 올바르게 따르지 않는 프로바이더를 거부**할 수 있습니다(MAY)**;
- DApp은 추가 검증 메커니즘 없이 자체 증명되고 사칭이나 나쁜 인센티브에 취약하므로 기능 감지에 `rdns` 값을 사용**해서는 안 됩니다(SHOULD NOT)**; 기능 발견 및 검증은 모두 이 인터페이스 사양의 범위를 벗어납니다.

### 프로바이더 상세 정보

`EIP6963ProviderDetail`은 지갑 프로바이더와 지갑 프로바이더에 대한 관련 메타데이터를 발표하기 위한 구성 인터페이스로 사용됩니다. `EIP6963ProviderDetail`은 `EIP6963ProviderInfo` 유형의 `info` 속성과 [EIP-1193](./eip-1193.md)에서 정의한 `EIP1193Provider` 유형의 `provider` 속성을 **반드시** 포함해야 합니다(MUST).

```typescript
interface EIP6963ProviderDetail {
  info: EIP6963ProviderInfo;
  provider: EIP1193Provider;
}
```

### Window 이벤트

프로바이더 충돌을 방지하기 위해 DApp과 지갑은 다양한 지갑을 발견하기 위해 이벤트를 발생시키고 eventListener를 인스턴스화할 것으로 예상됩니다. 이는 이벤트 동시성 루프를 형성합니다.

DApp 코드와 지갑 코드가 특정 순서로 실행되는 것이 보장되지 않으므로 이벤트는 이러한 경쟁 조건을 처리하도록 설계되었습니다.

이벤트를 발생시키기 위해 DApp과 지갑 모두 이벤트를 발생시키기 위해 `window.dispatchEvent` 함수를 **반드시** 사용해야 하고(MUST) 이벤트를 관찰하기 위해 `window.addEventListener` 함수를 **반드시** 사용해야 합니다(MUST). DApp과 지갑이 서로를 발견하기 위해 사용되는 두 개의 이벤트 인터페이스가 있습니다.

#### 발표 및 요청 이벤트

`EIP6963AnnounceProviderEvent` 인터페이스는 `eip6963:announceProvider` 문자열 값을 포함하는 `type` 속성과 `EIP6963ProviderDetail` 유형의 객체 값을 가진 `detail` 속성을 가진 `CustomEvent` 객체**여야 합니다(MUST)**. `EIP6963ProviderDetail` 객체는 `detail` 속성 값에 대해 `Object.freeze()`를 호출하여 동결**해야 합니다(SHOULD)**.

```typescript
// 지갑에 의해 발송되는 발표 이벤트
interface EIP6963AnnounceProviderEvent extends CustomEvent {
  type: "eip6963:announceProvider";
  detail: EIP6963ProviderDetail;
}
```

`EIP6963RequestProviderEvent` 인터페이스는 `eip6963:requestProvider` 문자열 값을 포함하는 `type` 속성을 가진 `Event` 객체**여야 합니다(MUST)**.

```typescript
// DApp에 의해 발송되는 요청 이벤트
interface EIP6963RequestProviderEvent extends Event {
  type: "eip6963:requestProvider";
}
```

지갑은 `window.dispatchEvent()` 함수 호출을 통해 DApp에 `EIP6963AnnounceProviderEvent`를 **반드시** 발표해야 합니다(MUST). 지갑은 DApp에서 발송된 `EIP6963RequestProviderEvent`를 잡기 위해 EventListener를 **반드시** 추가해야 합니다(MUST). 이 EventListener는 `EIP6963AnnounceProviderEvent`를 다시 발송하는 핸들러를 **반드시** 사용해야 합니다(MUST). 지갑의 이 재발표는 지갑의 초기 이벤트 발표가 지연되었거나 DApp이 EventListener를 초기화하기 전에 발생한 경우에 유용합니다. 이를 통해 다양한 지갑 프로바이더가 매번 다른 지갑이 연결되는 것과 같은 비결정적 지갑 동작을 생성할 수 있는 `window.ethereum` 네임스페이스를 오염시킬 필요 없이 DApp에 반응할 수 있습니다.

지갑은 불변 콘텐츠로 `"eip6963:announceProvider"` 이벤트를 발송하고 `"eip6963:requestProvider"` 이벤트를 수신합니다:

```typescript
let info: EIP6963ProviderInfo;
let provider: EIP1193Provider;

const announceEvent: EIP6963AnnounceProviderEvent = new CustomEvent(
  "eip6963:announceProvider",
  { detail: Object.freeze({ info, provider }) }
);

// 지갑은 이전에 실행된 DApp 코드가 들을 수 있는 발표 이벤트를 발송합니다
window.dispatchEvent(announceEvent);

// 지갑은 나중에 발송될 수 있는 요청 이벤트를 수신하고
// `EIP6963AnnounceProviderEvent`를 다시 발송합니다
window.addEventListener("eip6963:requestProvider", () => {
  window.dispatchEvent(announceEvent);
});
```

DApp은 `window.addEventListener()` 메서드를 통해 지갑이 발송한 `EIP6963AnnounceProviderEvent`를 **반드시** 수신해야 하고(MUST) DApp이 초기 페이지 로드 상호 작용 이후의 이벤트를 계속 처리할 수 있도록 페이지 수명 동안 이벤트 리스너를 **반드시** 제거하지 않아야 합니다(MUST NOT). DApp은 `EIP6963AnnounceProviderEvent` 핸들러가 초기화된 후 `window.dispatchEvent()` 함수 호출을 통해 `EIP6963RequestProviderEvent`를 **반드시** 발송해야 합니다(MUST).

```typescript
// DApp은 발표된 프로바이더를 수신합니다
window.addEventListener(
  "eip6963:announceProvider",
  (event: EIP6963AnnounceProviderEvent) => {}
);

// DApp은 이전에 실행된 지갑 코드가 들을 수 있는 요청 이벤트를 발송합니다
window.dispatchEvent(new Event("eip6963:requestProvider"));
```

DApp은 여러 지갑이 보낸 발표 이벤트에 포함된 다양한 `EIP6963ProviderDetail` 객체를 유지하도록 선택**할 수 있습니다(MAY)**. 따라서 사용자가 시간이 지남에 따라 다른 지갑을 사용하고자 하는 경우 사용자는 DApp의 인터페이스 내에서 이를 표현할 수 있고 DApp은 즉시 해당 새 지갑으로 트랜잭션을 보내도록 선택할 수 있습니다. 그렇지 않으면 DApp은 새 `EIP6963RequestProviderEvent`를 발송하여 지갑 발견 흐름을 다시 시작하여 잠재적으로 다른 지갑 세트를 발견**할 수 있습니다(MAY)**.

설명된 이벤트 오케스트레이션은 지갑 코드가 먼저 실행되든 DApp 코드가 먼저 실행되든 관계없이 DApp이 지갑을 발견할 수 있음을 보장합니다.

## 근거

이전 제안은 여러 당사자가 덮어쓸 수 있는 단일 변경 가능한 window 객체에 의존하는 메커니즘을 도입했습니다. 경쟁 조건, 네임스페이스 충돌 및 공유 변경 가능 객체에 대한 "오염" 공격 가능성을 피하기 위해 이벤트 기반 접근 방식을 선택했습니다. 이벤트 기반 오케스트레이션은 시간이 지남에 따라 다시 오케스트레이션될 수 있는 지갑과 DApp 사이의 양방향 통신 채널을 만듭니다.

JavaScript 이벤트 이름 규칙을 따르기 위해 이름은 현재 시제로 작성되고 이 문서의 번호(`EIP6963`)가 접두사로 붙습니다.

### 인터페이스

프로바이더 정보(`EIP6963ProviderInfo`)에 대한 인터페이스를 표준화하면 DApp이 사용자 친화적인 지갑 선택 모달을 채우는 데 필요한 모든 정보를 결정할 수 있습니다. 이는 Web3Modal, RainbowKit, Web3-Onboard 또는 ConnectKit과 같은 라이브러리에 의존하여 프로그래밍 방식으로 이러한 선택 모달을 생성하는 DApp에 특히 유용합니다.

발표된 프로바이더 인터페이스(`EIP6963ProviderDetail`)와 관련하여 하위 호환성을 위해 [EIP-1193](./eip-1193.md) 프로바이더 인터페이스를 그대로 두는 것이 중요했습니다. 이를 통해 준수 DApp이 둘 중 하나에 맞는 지갑과 인터페이스할 수 있고, 이 사양에 맞는 지갑이 레거시 DApp용 [EIP-1193](./eip-1193.md) 프로바이더를 여전히 주입할 수 있습니다. 레거시 DApp 또는 이 사양을 준수하는 DApp이 레거시 지갑에 연결하면 여러 개가 있는 경우 올바른 지갑이 선택된다고 보장할 수 없습니다.

## 하위 호환성

이 EIP는 `window.ethereum`을 대체할 필요가 없으므로 이 지갑 발견 방법으로 업데이트할 수 없는 기존 애플리케이션을 직접 중단하지 않습니다. 그러나 DApp이 여러 지갑 프로바이더의 발견을 보장하기 위해 이 EIP를 구현하는 것을 **권장하며(RECOMMENDED)** 발견이 실패할 때 대체로 사용하는 경우를 제외하고 `window.ethereum` 사용을 비활성화**해야 합니다(SHOULD)**. 마찬가지로 지갑은 이 EIP를 구현하지 않은 DApp과의 하위 호환성을 보장하기 위해 `window.ethereum`의 호환성을 유지**해야 합니다(SHOULD)**. 이전의 네임스페이스 충돌 문제를 방지하기 위해 지갑이 지갑별 네임스페이스 아래에 프로바이더 객체를 주입한 다음 `window.ethereum` 네임스페이스에 객체를 프록시하는 것도 **권장됩니다(RECOMMENDED)**.

## 참조 구현

### 지갑 프로바이더

기존 패턴과 병행하여 이 새 인터페이스를 지원하기 위한 지갑 프로바이더의 주입된 스크립트에 대한 참조 구현입니다.

```typescript
function onPageLoad() {
  let provider: EIP1193Provider;

  window.ethereum = provider;

  function announceProvider() {
    const info: EIP6963ProviderInfo = {
      uuid: "350670db-19fa-4704-a166-e52e178b59d2",
      name: "Example Wallet",
      icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>",
      rdns: "com.example.wallet"
    };
    window.dispatchEvent(
      new CustomEvent("eip6963:announceProvider", {
        detail: Object.freeze({ info, provider }),
      })
    );
  }

  window.addEventListener(
    "eip6963:requestProvider",
    (event: EIP6963RequestProviderEvent) => {
      announceProvider();
    }
  );

  announceProvider();
}
```

### DApp 구현

브라우저 확장 프로그램에 의해 주입된 여러 지갑 프로바이더를 표시하고 추적하기 위한 DApp의 참조 구현입니다.

```typescript
const providers: EIP6963ProviderDetail[];

function onPageLoad() {

  window.addEventListener(
    "eip6963:announceProvider",
    (event: EIP6963AnnounceProviderEvent) => {
      providers.push(event.detail);
    }
  );

  window.dispatchEvent(new Event("eip6963:requestProvider"));
}
```

## 보안 고려사항

### EIP-1193 보안 고려사항

[EIP-1193](./eip-1193.md)의 보안 고려사항이 이 EIP에 적용됩니다. 구현자는 사용하는 프로바이더의 지침을 고려하고 따를 것으로 예상됩니다.

### 지갑 프로바이더 객체의 프로토타입 오염

브라우저 확장 프로그램, 따라서 지갑 확장 프로그램은 설계상 페이지와 프로바이더 객체의 내용을 수정할 수 있습니다. 다양한 지갑의 프로바이더 객체는 트랜잭션 데이터를 통신하기 위한 매우 신뢰할 수 있는 인터페이스로 간주됩니다. 페이지나 다양한 다른 확장 프로그램이 DApp과 지갑 간의 상호 작용을 예상치 못한 방식으로 수정하는 것을 방지하기 위해 가장 좋은 방법은 지갑이 `eip6963:announceProvider` 이벤트에서 발송하기 전에 `EIP1193Provider` 객체에 대해 `object.freeze()`를 사용하여 프로바이더 발견 객체를 "동결"하는 것입니다. 그러나 페이지가 객체를 몽키 패치해야 하는 웹 호환성 주변에서 어려움이 발생할 수 있습니다. 이와 같은 시나리오에서는 보안과 웹 호환성 사이에 트레이드오프가 필요하며 지갑 구현자가 고려해야 합니다.

### 지갑 사칭 및 조작

마찬가지로 DApp은 다른 지갑을 변조하거나 수정하기 위해 속성이나 함수가 수정되는 오작동을 적극적으로 감지할 것으로 예상됩니다. 이를 쉽게 달성할 수 있는 한 가지 방법은 두 `EIP6963ProviderInfo` 객체 내의 `uuid` 속성이 일치하는 경우를 찾는 것입니다. DApp 및 DApp 발견 라이브러리는 사용자를 보호하기 위해 `EIP6963ProviderInfo` 객체가 변조되는 다른 잠재적 방법을 고려하고 이를 방지하기 위한 추가 완화 기술을 고려해야 합니다.

### SVG JavaScript 실행 방지

SVG 이미지 사용은 JavaScript 코드를 포함할 수 있으므로 크로스 사이트 스크립팅 위험을 도입합니다. 이 JavaScript는 페이지 컨텍스트 내에서 실행되므로 페이지나 페이지의 내용을 수정할 수 있습니다. 따라서 아이콘을 렌더링하는 경험을 고려할 때 DApp은 이미지가 페이지나 다른 지갑에 대한 악의적인 수정을 숨기기 위한 난독화 기술로 사용되는 것을 방지하기 위해 이러한 우려를 처리하는 방법에 대해 고려해야 합니다.

### 지갑 핑거프린팅 방지

이 설계에서 사용하는 동시성 이벤트 루프의 한 가지 장점은 DApp 또는 지갑이 프로바이더를 발표하는 흐름을 시작할 수 있는 방식으로 작동한다는 것입니다. 이러한 이유로 지갑 구현자는 이제 모든 페이지에 자신을 발표할지 또는 `window.ethereum` 객체의 주입에 의해 사용자가 핑거프린팅되는 능력을 줄이기 위한 대안적 수단을 시도할지 여부를 고려할 수 있습니다. 고려할 대안적 흐름의 몇 가지 예는 DApp이 `eip6963:requestProvider`를 발표할 때까지 프로바이더 객체를 주입하기를 기다리는 것입니다. 그 시점에서 지갑은 사용자에게 지갑 주소를 공유하고 싶은지 묻는 UI 동의 흐름을 시작할 수 있습니다. 이를 통해 지갑이 "비공개 연결" 기능 옵션을 활성화할 수 있습니다. 그러나 이 접근 방식을 취하면 지갑은 이 EIP를 지원하지 않는 DApp과의 하위 호환성을 어떻게 지원할 것인지도 고려해야 합니다.

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.

[RFC-1034]: https://www.rfc-editor.org/rfc/rfc1034
[RFC-2119]: https://www.rfc-editor.org/rfc/rfc2119
[RFC-2397]: https://www.rfc-editor.org/rfc/rfc2397
[RFC-3986]: https://www.rfc-editor.org/rfc/rfc3986
[RFC-4122]: https://www.rfc-editor.org/rfc/rfc4122
