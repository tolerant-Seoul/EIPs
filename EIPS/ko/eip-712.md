---
eip: 712
title: 타입화된 구조화 데이터 해싱 및 서명
description: 단순한 바이트스트링이 아닌 타입화된 구조화 데이터의 해싱 및 서명 절차.
author: Remco Bloemen (@Recmo), Leonid Logvinov (@LogvinovLeon), Jacob Evans (@dekz)
discussions-to: https://ethereum-magicians.org/t/eip-712-eth-signtypeddata-as-a-standard-for-machine-verifiable-and-human-readable-typed-data-signing/397
status: Final
type: Standards Track
category: Interface
created: 2017-09-12
requires: 155, 191
lang: ko
original: ../eip-712.md
---

## 요약

이것은 단순한 바이트스트링이 아닌 타입화된 구조화 데이터의 해싱 및 서명 표준입니다. 다음을 포함합니다:

* 인코딩 함수의 정확성을 위한 이론적 프레임워크,
* Solidity 구조체와 유사하고 호환되는 구조화 데이터 사양,
* 해당 구조체 인스턴스를 위한 안전한 해싱 알고리즘,
* 서명 가능한 메시지 집합에 해당 인스턴스의 안전한 포함,
* 도메인 분리를 위한 확장 가능한 메커니즘,
* 새로운 RPC 호출 `eth_signTypedData`, 그리고
* EVM에서의 해싱 알고리즘의 최적화된 구현.

재생 공격 방지는 포함되지 않습니다.

## 동기

데이터 서명은 바이트스트링만 신경 쓴다면 해결된 문제입니다. 불행히도 실제 세계에서는 복잡하고 의미 있는 메시지에 관심을 가집니다. 구조화 데이터 해싱은 간단하지 않으며 오류는 시스템의 보안 속성 손실을 초래합니다.

따라서 "자체 암호화를 만들지 마라"는 격언이 적용됩니다. 대신 동료 검토를 거친 잘 테스트된 표준 방법을 사용해야 합니다. 이 EIP는 그 표준이 되는 것을 목표로 합니다.

이 EIP는 온체인 사용을 위한 오프체인 메시지 서명의 사용성을 개선하는 것을 목표로 합니다. 가스를 절약하고 블록체인의 트랜잭션 수를 줄이기 때문에 오프체인 메시지 서명의 채택이 증가하고 있습니다. 현재 서명된 메시지는 메시지를 구성하는 항목에 대한 컨텍스트가 거의 없이 사용자에게 표시되는 불투명한 16진수 문자열입니다.

![eth_sign 스크린샷](../../assets/eip-712/eth_sign.png)

여기서 우리는 데이터를 구조와 함께 인코딩하여 서명할 때 사용자가 확인할 수 있도록 표시하는 체계를 설명합니다. 아래는 현재 제안에 따라 메시지에 서명할 때 사용자에게 표시될 수 있는 예시입니다.

![eth_signTypedData 스크린샷](../../assets/eip-712/eth_signTypedData.png)

## 사양

서명 가능한 메시지 집합은 트랜잭션과 바이트스트링 `𝕋 ∪ 𝔹⁸ⁿ`에서 구조화 데이터 `𝕊`도 포함하도록 확장됩니다. 따라서 새로운 서명 가능한 메시지 집합은 `𝕋 ∪ 𝔹⁸ⁿ ∪ 𝕊`입니다. 이들은 다음과 같이 해싱 및 서명에 적합한 바이트스트링으로 인코딩됩니다:

* `encode(transaction : 𝕋) = RLP_encode(transaction)`
* `encode(message : 𝔹⁸ⁿ) = "\x19Ethereum Signed Message:\n" ‖ len(message) ‖ message` 여기서 `len(message)`는 `message`의 바이트 수를 나타내는 _0으로 패딩되지 않은_ ascii-decimal 인코딩입니다.
* `encode(domainSeparator : 𝔹²⁵⁶, message : 𝕊) = "\x19\x01" ‖ domainSeparator ‖ hashStruct(message)` 여기서 `domainSeparator`와 `hashStruct(message)`는 아래에 정의됩니다.

이 인코딩은 결정적입니다. 개별 구성요소가 결정적이기 때문입니다. 세 가지 경우가 항상 첫 번째 바이트에서 다르기 때문에 인코딩은 단사입니다. (`RLP_encode(transaction)`은 `\x19`로 시작하지 않습니다.)

인코딩은 [ERC-191][ERC-191]과 호환됩니다. '버전 바이트'는 `0x01`로 고정되고, '버전 특정 데이터'는 32바이트 도메인 구분자 `domainSeparator`이며, '서명할 데이터'는 32바이트 `hashStruct(message)`입니다.

[ERC-191]: ./eip-191.md

### 타입화된 구조화 데이터 `𝕊`의 정의

모든 구조화 데이터 집합을 정의하기 위해 허용 가능한 유형을 정의하는 것부터 시작합니다. ABIv2와 마찬가지로 이들은 Solidity 유형과 밀접하게 관련되어 있습니다. 정의를 설명하기 위해 Solidity 표기법을 채택하는 것이 도움이 됩니다. 표준은 Ethereum Virtual Machine에 특화되어 있지만 상위 수준 언어에 대해서는 불가지론적이 되는 것을 목표로 합니다. 예:

```Solidity
struct Mail {
    address from;
    address to;
    string contents;
}
```

**정의**: _구조체 유형_은 이름으로 유효한 식별자를 가지며 0개 이상의 멤버 변수를 포함합니다. 멤버 변수는 멤버 유형과 이름을 가집니다.

**정의**: _멤버 유형_은 원자 유형, 동적 유형 또는 참조 유형일 수 있습니다.

**정의**: _원자 유형_은 `bytes1`부터 `bytes32`, `uint8`부터 `uint256`, `int8`부터 `int256`, `bool` 및 `address`입니다. 이들은 Solidity의 정의와 일치합니다. `uint`와 `int` 별칭은 없습니다. 컨트랙트 주소는 항상 일반 `address`입니다. 고정 소수점 숫자는 표준에서 지원되지 않습니다. 이 표준의 향후 버전에서 새로운 원자 유형을 추가할 수 있습니다.

**정의**: _동적 유형_은 `bytes`와 `string`입니다. 이들은 유형 선언 목적으로는 원자 유형과 같지만 인코딩에서의 처리는 다릅니다.

**정의**: _참조 유형_은 배열과 구조체입니다. 배열은 고정 크기 또는 동적이며 각각 `Type[n]` 또는 `Type[]`로 표시됩니다. 구조체는 이름으로 다른 구조체에 대한 참조입니다. 표준은 재귀 구조체 유형을 지원합니다.

**정의**: 구조화된 타입 데이터 집합 `𝕊`는 모든 구조체 유형의 모든 인스턴스를 포함합니다.

### `hashStruct`의 정의

`hashStruct` 함수는 다음과 같이 정의됩니다:

* `hashStruct(s : 𝕊) = keccak256(typeHash ‖ encodeData(s))` 여기서 `typeHash = keccak256(encodeType(typeOf(s)))`

**참고**: `typeHash`는 주어진 구조체 유형에 대한 상수이며 런타임에 계산할 필요가 없습니다.

### `encodeType`의 정의

구조체의 유형은 `name ‖ "(" ‖ member₁ ‖ "," ‖ member₂ ‖ "," ‖ … ‖ memberₙ ")"`로 인코딩됩니다. 각 멤버는 `type ‖ " " ‖ name`으로 작성됩니다. 예를 들어, 위의 `Mail` 구조체는 `Mail(address from,address to,string contents)`로 인코딩됩니다.

구조체 유형이 다른 구조체 유형을 참조하는 경우(그리고 이들이 더 많은 구조체 유형을 참조하는 경우), 참조된 구조체 유형 집합이 수집되고 이름으로 정렬되어 인코딩에 추가됩니다. 예제 인코딩은 `Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)`입니다.

### `encodeData`의 정의

구조체 인스턴스의 인코딩은 `enc(value₁) ‖ enc(value₂) ‖ … ‖ enc(valueₙ)`입니다. 즉, 유형에 나타나는 순서대로 인코딩된 멤버 값의 연결입니다. 각 인코딩된 멤버 값은 정확히 32바이트입니다.

원자 값은 다음과 같이 인코딩됩니다: Boolean `false`와 `true`는 각각 `uint256` 값 `0`과 `1`로 인코딩됩니다. 주소는 `uint160`으로 인코딩됩니다. 정수 값은 256비트로 부호 확장되고 빅 엔디안 순서로 인코딩됩니다. `bytes1`부터 `bytes31`은 시작(인덱스 `0`)과 끝(인덱스 `length - 1`)이 있는 배열이며, 끝에 0으로 패딩되어 `bytes32`가 되고 시작부터 끝까지 순서로 인코딩됩니다. 이것은 ABI v1 및 v2에서의 인코딩과 일치합니다.

동적 값 `bytes`와 `string`은 내용의 `keccak256` 해시로 인코딩됩니다.

배열 값은 내용의 연결된 `encodeData`의 `keccak256` 해시로 인코딩됩니다(즉, `SomeType[5]`의 인코딩은 `SomeType` 유형의 다섯 멤버를 포함하는 구조체의 인코딩과 동일합니다).

구조체 값은 `hashStruct(value)`로 재귀적으로 인코딩됩니다. 이것은 순환 데이터에 대해 정의되지 않습니다.

### `domainSeparator`의 정의

```Solidity
domainSeparator = hashStruct(eip712Domain)
```

여기서 `eip712Domain`의 유형은 아래 필드 중 하나 이상을 가진 `EIP712Domain`이라는 이름의 구조체입니다. 프로토콜 설계자는 서명 도메인에 적합한 필드만 포함하면 됩니다. 사용되지 않는 필드는 구조체 유형에서 제외됩니다.

* `string name` - 서명 도메인의 사용자가 읽을 수 있는 이름, 즉 DApp 또는 프로토콜의 이름.
* `string version` - 서명 도메인의 현재 주요 버전. 다른 버전의 서명은 호환되지 않습니다.
* `uint256 chainId` - [EIP-155][EIP-155] 체인 ID. 사용자 에이전트는 현재 활성 체인과 일치하지 않으면 서명을 _거부해야 합니다_.
* `address verifyingContract` - 서명을 검증할 컨트랙트의 주소. 사용자 에이전트는 컨트랙트별 피싱 방지를 _수행할 수 있습니다_.
* `bytes32 salt` - 프로토콜에 대한 모호성을 해소하는 솔트. 이것은 최후의 수단인 도메인 구분자로 사용될 수 있습니다.

[EIP-155]: ./eip-155.md

### `eth_signTypedData` JSON RPC 사양

메서드 `eth_signTypedData`가 Ethereum JSON-RPC에 추가됩니다. 이 메서드는 `eth_sign`과 유사합니다.

#### eth_signTypedData

sign 메서드는 위에서 정의된 대로 `sign(keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message)))`로 Ethereum 특정 서명을 계산합니다.

**참고**: 서명할 주소는 잠금 해제되어 있어야 합니다.

##### 매개변수

1. `Address` - 20 바이트 - 메시지에 서명할 계정의 주소.
2. `TypedData` - 서명할 타입화된 구조화 데이터.

타입 데이터는 유형 정보, 도메인 구분자 매개변수 및 메시지 객체를 포함하는 JSON 객체입니다. 아래는 `TypedData` 매개변수에 대한 json-schema 정의입니다.

```JavaScript
{
  type: 'object',
  properties: {
    types: {
      type: 'object',
      properties: {
        EIP712Domain: {type: 'array'},
      },
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {type: 'string'},
            type: {type: 'string'}
          },
          required: ['name', 'type']
        }
      },
      required: ['EIP712Domain']
    },
    primaryType: {type: 'string'},
    domain: {type: 'object'},
    message: {type: 'object'}
  },
  required: ['types', 'primaryType', 'domain', 'message']
}
```

##### 반환값

`DATA`: 서명. `eth_sign`과 마찬가지로 `0x`로 시작하는 16진수 인코딩된 65바이트 배열입니다. Yellow Paper의 부록 F에서 `r`, `s` 및 `v` 매개변수를 빅 엔디안 형식으로 인코딩합니다. 바이트 0...32에는 `r` 매개변수, 바이트 32...64에는 `s` 매개변수, 마지막 바이트에는 `v` 매개변수가 포함됩니다. `v` 매개변수는 [EIP-155][eip-155]에 지정된 대로 체인 ID를 포함합니다.

##### 예시

요청:

```shell
curl -X POST --data '{"jsonrpc":"2.0","method":"eth_signTypedData","params":["0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826", {"types":{"EIP712Domain":[{"name":"name","type":"string"},{"name":"version","type":"string"},{"name":"chainId","type":"uint256"},{"name":"verifyingContract","type":"address"}],"Person":[{"name":"name","type":"string"},{"name":"wallet","type":"address"}],"Mail":[{"name":"from","type":"Person"},{"name":"to","type":"Person"},{"name":"contents","type":"string"}]},"primaryType":"Mail","domain":{"name":"Ether Mail","version":"1","chainId":1,"verifyingContract":"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"},"message":{"from":{"name":"Cow","wallet":"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"},"to":{"name":"Bob","wallet":"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"},"contents":"Hello, Bob!"}}],"id":1}'
```

결과:

```JavaScript
{
  "id":1,
  "jsonrpc": "2.0",
  "result": "0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"
}
```

## 근거

`encode` 함수는 새로운 유형에 대한 새로운 경우로 확장됩니다. 인코딩의 첫 번째 바이트가 경우를 구분합니다. 같은 이유로 도메인 구분자나 `typeHash`로 즉시 시작하는 것은 안전하지 않습니다. 어렵지만, 유효한 RLP 인코딩 트랜잭션의 접두사이기도 한 `typeHash`를 구성할 수 있을 수 있습니다.

도메인 구분자는 그렇지 않으면 동일한 구조의 충돌을 방지합니다. 두 DApp이 호환되어서는 안 되는 `Transfer(address from,address to,uint256 amount)`와 같은 동일한 구조를 생각해낼 수 있습니다. 도메인 구분자를 도입함으로써 DApp 개발자는 서명 충돌이 없을 것임을 보장받습니다.

도메인 구분자는 또한 주어진 DApp 내에서 동일한 구조체 인스턴스에 대한 여러 고유한 서명 사용 사례를 허용합니다. 이전 예에서 아마도 `from`과 `to` 모두의 서명이 필요할 수 있습니다. 두 개의 고유한 도메인 구분자를 제공함으로써 이러한 서명을 서로 구별할 수 있습니다.

## 보안 고려사항

### 재생 공격

이 표준은 메시지 서명 및 서명 검증에 관한 것입니다. 많은 실제 애플리케이션에서 서명된 메시지는 예를 들어 토큰 교환과 같은 작업을 승인하는 데 사용됩니다. 구현자는 애플리케이션이 동일한 서명된 메시지를 두 번 볼 때 올바르게 동작하도록 해야 하는 것이 _매우 중요_합니다. 예를 들어, 반복된 메시지는 거부되어야 하거나 승인된 작업은 멱등성이 있어야 합니다. 이것이 어떻게 구현되는지는 애플리케이션에 따라 다르며 이 표준의 범위를 벗어납니다.

### 프론트러닝 공격

서명을 안정적으로 브로드캐스트하는 메커니즘은 애플리케이션에 따라 다르며 이 표준의 범위를 벗어납니다. 서명이 컨트랙트에서 사용하기 위해 블록체인에 브로드캐스트될 때 애플리케이션은 프론트러닝 공격으로부터 안전해야 합니다. 이런 종류의 공격에서 공격자는 서명을 가로채서 원래 의도된 사용이 이루어지기 전에 컨트랙트에 제출합니다. 서명이 먼저 공격자에 의해 제출될 때 애플리케이션은 올바르게 동작해야 합니다. 예를 들어 거부하거나 서명자가 의도한 것과 정확히 동일한 효과를 생성해야 합니다.

## 저작권

저작권 및 관련 권리는 [CC0](../LICENSE.md)를 통해 포기됩니다.
