---
eip: 7702
title: EOA 코드 설정
description: EOA에 코드를 영구적으로 설정하는 새로운 트랜잭션 유형 추가
author: Vitalik Buterin, Sam Wilson, Ansgar Dietrichs, lightclient
status: Final
type: Standards Track
category: Core
created: 2024-05-07
requires: 2, 161, 1052, 2718, 2929, 2930, 3541, 3607, 4844
lang: ko
original: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7702.md
---

## 요약

외부 소유 계정(EOA)이 자신의 계정에 코드를 설정할 수 있게 하는 새로운 EIP-2718 트랜잭션 유형을 추가합니다. 이는 트랜잭션에 승인 튜플 목록(`[chain_id, address, nonce, y_parity, r, s]` 형식)을 첨부하여 수행됩니다. 각 튜플에 대해 위임 지시자(`0xef0100 || address`)가 승인 계정의 코드에 기록됩니다.

## 동기

스마트 컨트랙트 지갑 생태계의 큰 발전에도 불구하고, EOA는 애플리케이션 전반에 걸친 UX 개선의 광범위한 채택을 저해해 왔습니다. 이 EIP는 다음 세 가지 기능을 중심으로 설계되었습니다:

### 배칭 (Batching)
동일한 사용자의 여러 작업을 하나의 원자적 트랜잭션에서 수행할 수 있게 합니다. 일반적인 예는 ERC-20 승인 후 해당 승인을 사용하는 것입니다. 이는 현재 DEX에서 두 번의 트랜잭션이 필요한 일반적인 워크플로우입니다.

### 스폰서십 (Sponsorship)
계정 X가 계정 Y를 대신하여 트랜잭션 비용을 지불합니다. 계정 X는 이 서비스에 대해 다른 ERC-20으로 보상받을 수 있거나, 사용자의 트랜잭션을 무료로 포함하는 애플리케이션 운영자일 수 있습니다.

### 권한 축소 (Privilege De-escalation)
사용자가 서브키에 서명하고 계정에 대한 전역 접근보다 훨씬 약한 특정 권한을 부여할 수 있습니다. 예를 들어:
- ETH가 아닌 ERC-20 토큰만 사용하는 권한
- 하루에 총 잔액의 1%까지만 사용하는 권한
- 특정 애플리케이션과만 상호작용하는 권한

## 명세

### 매개변수

| 매개변수 | 값 |
|---------|-----|
| `SET_CODE_TX_TYPE` | `0x04` |
| `MAGIC` | `0x05` |
| `PER_AUTH_BASE_COST` | `12500` |
| `PER_EMPTY_ACCOUNT_COST` | `25000` |

### 코드 설정 트랜잭션

새로운 EIP-2718 트랜잭션("코드 설정 트랜잭션")이 도입됩니다. `TransactionPayload`는 다음의 RLP 직렬화입니다:

```
rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
destination, value, data, access_list, authorization_list, signature_y_parity,
signature_r, signature_s])

authorization_list = [[chain_id, address, nonce, y_parity, r, s], ...]
```

### 동작

승인 목록은 트랜잭션 실행 부분이 시작되기 전에, 발신자의 논스가 증가된 후 처리됩니다.

각 `[chain_id, address, nonce, y_parity, r, s]` 튜플에 대해:

1. 체인 ID가 0이거나 현재 체인의 ID인지 확인
2. `nonce`가 `2**64 - 1` 미만인지 확인
3. `authority = ecrecover(msg, y_parity, r, s)` 계산
   - `msg = keccak(MAGIC || rlp([chain_id, address, nonce]))`
4. `authority`를 `accessed_addresses`에 추가
5. `authority`의 코드가 비어있거나 이미 위임되었는지 확인
6. `authority`의 논스가 `nonce`와 같은지 확인
7. `authority`가 비어있지 않으면 글로벌 환불 카운터에 `PER_EMPTY_ACCOUNT_COST - PER_AUTH_BASE_COST` 가스 추가
8. `authority`의 코드를 `0xef0100 || address`로 설정 (위임 지시자)
   - `address`가 `0x0`이면 위임 지시자를 쓰지 않고 코드 해시를 빈 코드 해시로 재설정
9. `authority`의 논스를 1 증가

### 위임 지시자

위임 지시자는 EIP-3541에서 금지된 옵코드 `0xef`를 사용하여 코드가 일반 코드와 다르게 처리되어야 함을 나타냅니다. 위임은 모든 코드 실행 작업이 주소 포인터를 따라 실행할 코드를 얻도록 강제합니다.

영향을 받는 실행 작업:
- `CALL`, `CALLCODE`, `DELEGATECALL`, `STATICCALL`
- `destination`이 위임 지시자가 있는 주소를 가리키는 모든 트랜잭션

### 가스 비용

새 트랜잭션의 내재 비용은 EIP-2930에서 상속됩니다:
- `21000 + 16 * 비제로 콜데이터 바이트 + 4 * 제로 콜데이터 바이트 + 1900 * 액세스 목록 스토리지 키 수 + 2400 * 액세스 목록 주소 수`
- 추가로 `PER_EMPTY_ACCOUNT_COST * 승인 목록 길이`

## 근거

### 코드 위임의 영속성

초기 초안에서는 트랜잭션 동안만 일시적으로 코드를 설정하는 아이디어가 있었습니다. 그러나 영구적인 위임은 사용자가 정기적으로 새로운 고유한 위임을 배포하지 않도록 충분한 마찰을 만들어, UX 개발의 파편화를 최소화하고 작업 흐름을 통합합니다.

### initcode 없음

initcode 실행은 여러 이유로 바람직하지 않습니다:
- 광범위한 테스트가 필요한 새로운 실행 모드 생성
- 표준 스마트 컨트랙트 지갑으로 불가능한 목적으로 사용될 수 있음
- 개발자가 위임 후 EOA에 대한 표준 호출로 초기화를 수행하도록 강제

### 애플리케이션 및 지갑과의 상호작용

애플리케이션은 사용자에게 승인 서명을 요청할 수 있다고 기대해서는 **안 됩니다**. 지갑은 이러한 인터페이스를 제공하지 않아야 합니다.

**이 인터페이스를 제공하는 안전한 방법은 없습니다.** 승인에 의해 지정된 코드는 계정에 대한 무제한 접근 권한을 가지며 항상 지갑에 의해 면밀히 감사되어야 합니다.

### 미래 계정 추상화와의 전방 호환성

이 EIP는 ERC-4337 또는 RIP-7560의 세부 사항을 과도하게 내장하지 않으면서 최종 계정 추상화와 전방 호환되도록 설계되었습니다.

## 역호환성

이 EIP는 몇 가지 불변성을 깨뜨립니다:

- 계정 잔액은 해당 계정에서 발생한 트랜잭션의 결과로만 감소할 수 있음
  - 위임되면 계정에 대한 모든 호출이 잔액을 감소시킬 수 있음
- EOA 논스는 트랜잭션 실행이 시작된 후 증가할 수 없음
  - 위임되면 실행 중 생성 작업을 호출하여 논스가 증가할 수 있음
- `tx.origin == msg.sender`는 실행의 최상위 프레임에서만 true일 수 있음
  - 위임되면 트랜잭션당 여러 호출을 실행할 수 있음

## 보안 고려사항

### 안전한 위임 컨트랙트 구현

위임 컨트랙트가 주의해야 하고 계정의 권한으로부터 서명이 필요한 함정들:

- **재생 보호** (논스): 없으면 악의적인 행위자가 서명을 재사용하여 효과를 반복할 수 있음
- **value**: 없으면 악의적인 스폰서가 호출 대상에서 예상치 못한 효과를 일으킬 수 있음
- **gas**: 없으면 악의적인 스폰서가 호출 대상이 가스 부족으로 실패하게 하여 피후원자를 해칠 수 있음
- **target / calldata**: 없으면 악의적인 행위자가 임의의 컨트랙트에서 임의의 함수를 호출할 수 있음

잘못 구현된 위임은 **악의적인 행위자가 서명자의 EOA를 거의 완전히 제어할 수 있게 합니다**.

### 초기화 프론트 러닝

스마트 컨트랙트 지갑 개발자는 실행 없이 계정에 코드를 설정하는 것의 의미를 고려해야 합니다. 관찰자가 자신이 제어하는 계정으로 위임의 초기화를 프론트 러닝하는 것을 방지하기 위해, 초기 설정 목적의 초기 콜데이터가 ecrecover를 사용하여 EOA의 키로 서명되었는지 확인해야 합니다.

### 스토리지 관리

계정의 위임을 변경하는 것은 보안에 중요한 작업이며, 특히 새로 위임된 코드가 이전 코드의 업그레이드로 목적적으로 설계되고 테스트되지 않은 경우 가볍게 수행해서는 안 됩니다.

위임 컨트랙트 간의 안전한 마이그레이션을 위해 ERC-7201과 같은 표준화된 스토리지 패턴을 사용하는 것이 중요합니다.

### 스폰서 트랜잭션 중계자

`authorized` 계정이 승인을 무효화하거나(논스 증가) 관련 자산을 계정에서 빼내어 스폰서 트랜잭션 중계자가 보상 없이 가스를 소비하게 할 수 있습니다. 중계자는 보증금 요구 또는 평판 시스템 구현으로 이러한 경우에 대비해야 합니다.

## 저작권

저작권 및 관련 권리는 CC0를 통해 포기되었습니다.
