---
eip: 7710
title: 스마트 컨트랙트 위임
author: Ryan McPeck, Dan Finlay, Rob Dawson, Derek Chiang
status: Draft
type: Standards Track
category: ERC
created: 2024-05-20
requires: 1271, 7579
lang: ko
original: https://github.com/ethereum/ERCs/blob/master/ERCS/erc-7710.md
---

## 요약

이 제안은 "스마트 컨트랙트가 다른 스마트 컨트랙트 또는 외부 소유 계정(EOA)에 기능을 위임하는 표준 방법"을 수립합니다. 이 프레임워크는 위임 컨트랙트가 DelegationManager를 승인하여 원하는 작업을 실행할 수 있도록 하며, ERC-4337과 호환됩니다.

## 동기

### 핵심 문제

현재 스마트 컨트랙트 상호작용은 하드코딩된 권한이나 사용자 정의 중개 컨트랙트를 필요로 하여 복잡성, 높은 가스 비용, 하위 호환성 저하를 야기합니다.

### 해결되는 주요 과제

| 과제 | 설명 |
|------|------|
| 반복적인 메시지 서명 | 빈번한 상호작용을 위한 반복 서명이 사용자 마찰 발생 |
| 경직된 상호작용 모델 | 동적 권한 위임 제한 |
| 높은 운영 및 배포 비용 | 사용자 정의 컨트랙트 배포 필요 |

### 제안된 솔루션

"단일 서명을 통한 장기 세션 및 위임된 권한"을 가능하게 하여:

- **지속적인 dApp 세션**: 반복 서명 없이 지속되는 세션
- **제한된 권한**: AI 에이전트/자동화 시스템을 위한 범위 지정 권한
- **공유 가능한 초대 링크**: 특정 기능이 포함된 링크
- **제3자 위임자**: 정의된 정책 제약 내에서 운영

## 명세

### 핵심 용어

| 용어 | 설명 |
|------|------|
| **Delegator** | 위임을 생성하는 스마트 컨트랙트 |
| **Delegation Manager** | 권한을 검증하고 작업을 실행하는 스마트 컨트랙트 (`ERC7710Manager` 구현) |
| **Delegation** | 특정 작업을 수행하기 위해 부여된 권한 |
| **Delegate** | 상환 권한이 있는 컨트랙트, 계정 또는 EOA |
| **Redeemer** | 적극적으로 위임을 사용하는 Delegate |

### 위임 획득

이 명세는 의도적으로 위임을 획득하는 메커니즘을 제외하고, 상환 검증에만 집중합니다. 구현 방법은 다양할 수 있습니다 (예: ERC-7715 또는 기타 프로토콜).

### 상환 흐름

```
┌─────────────┐    redeemDelegations()    ┌────────────────────┐
│   Delegate  │ ─────────────────────────►│ Delegation Manager │
│  (Redeemer) │                           │                    │
└─────────────┘                           └─────────┬──────────┘
                                                    │
                                          검증 및 실행
                                                    │
                                                    ▼
                                          ┌─────────────────┐
                                          │    Delegator    │
                                          │ (Smart Account) │
                                          └─────────────────┘
```

Delegate가 위임을 상환할 때:
1. Delegation Manager의 `redeemDelegations` 호출
2. 작업과 권한 증명 전달
3. Manager가 위임 검증
4. Delegator를 호출하여 지정된 기능 실행

### 핵심 인터페이스: ERC7710Manager

```solidity
interface ERC7710Manager {
    /**
     * @notice 위임을 상환하여 작업 실행
     * @param _permissionContexts 특정 작업에 대한 권한 데이터
     * @param _modes 실행 동작 (ERC-7579에서)
     * @param _executionCallData 인코딩된 실행 데이터
     */
    function redeemDelegations(
        bytes[] calldata _permissionContexts,
        bytes32[] calldata _modes,
        bytes[] calldata _executionCallData
    ) external;
}
```

#### 매개변수 설명

| 매개변수 | 설명 |
|----------|------|
| `_permissionContexts` | 특정 작업에 대한 권한 데이터 배열 |
| `_modes` | 실행 동작 (ERC-7579 정의) |
| `_executionCallData` | 인코딩된 실행 데이터 배열 |

**중요**: 모든 배열은 동일한 길이여야 하며, 튜플이 원자성을 보장합니다.

### 실행 모드 (ERC-7579 호환)

```solidity
// 실행 모드 인코딩
bytes32 mode = bytes32(
    uint256(callType) << 248 |     // 1 바이트: 호출 유형
    uint256(execType) << 240 |     // 1 바이트: 실행 유형
    uint256(reserved) << 208 |     // 4 바이트: 예약됨
    uint256(selector) << 176 |     // 4 바이트: 모드 셀렉터
    uint256(payload)               // 22 바이트: 페이로드
);
```

**호출 유형**:
- `0x00`: 단일 호출
- `0x01`: 배치 호출
- `0xfe`: staticcall
- `0xff`: delegatecall

### 권한 검증

명시적 검사 메서드 대신, DApp은 다음을 통해 권한을 검증해야 합니다:

```typescript
async function verifyAndExecute(
  delegationManager: Address,
  permissionContext: Hex,
  mode: Hex,
  executionCallData: Hex
) {
  // 1. redeemDelegations 호출 시뮬레이션
  try {
    await publicClient.simulateContract({
      address: delegationManager,
      abi: ERC7710ManagerABI,
      functionName: 'redeemDelegations',
      args: [[permissionContext], [mode], [executionCallData]]
    });

    // 2. 시뮬레이션 성공 시 실제 실행
    return await walletClient.writeContract({
      address: delegationManager,
      abi: ERC7710ManagerABI,
      functionName: 'redeemDelegations',
      args: [[permissionContext], [mode], [executionCallData]]
    });
  } catch (error) {
    // 3. 실패 시 권한 재요청
    throw new Error('Permission verification failed');
  }
}
```

### Delegation 구조 예시

```solidity
struct Delegation {
    address delegate;           // 권한을 받는 주소
    address delegator;          // 권한을 부여하는 주소
    uint256 authority;          // 권한 식별자
    Caveat[] caveats;          // 제약 조건
    uint256 salt;              // 고유성을 위한 솔트
    bytes signature;           // 위임자 서명
}

struct Caveat {
    address enforcer;          // 제약 시행자 컨트랙트
    bytes terms;               // 제약 조건 데이터
}
```

### Caveat (제약 조건) 예시

```solidity
// 허용된 대상만 호출 가능
contract AllowedTargetsEnforcer {
    function beforeHook(
        bytes calldata terms,
        bytes calldata,
        bytes32 mode,
        bytes calldata executionCallData,
        bytes32,
        address,
        address
    ) external pure {
        address[] memory allowedTargets = abi.decode(terms, (address[]));
        address target = _extractTarget(executionCallData);

        require(_isAllowed(target, allowedTargets), "Target not allowed");
    }
}

// 토큰 한도 제한
contract TokenAllowanceEnforcer {
    mapping(bytes32 => uint256) public spent;

    function beforeHook(
        bytes calldata terms,
        bytes calldata,
        bytes32,
        bytes calldata executionCallData,
        bytes32 delegationHash,
        address,
        address
    ) external {
        (address token, uint256 limit) = abi.decode(terms, (address, uint256));
        uint256 amount = _extractAmount(executionCallData);

        spent[delegationHash] += amount;
        require(spent[delegationHash] <= limit, "Allowance exceeded");
    }
}
```

## 근거

### 설계 원칙

| 원칙 | 설명 |
|------|------|
| **유연성** | 광범위한 작업 위임을 가능하게 하는 최소하지만 강력한 인터페이스 |
| **상호운용성** | ERC-1271 및 ERC-4337과 호환 |
| **사용성** | 의미 있는 참여를 극대화하면서 사용자 상호작용 빈도 감소 |

### 이전 설계에서의 발전

이전 반복은 위임자가 표준화된 메서드를 구현해야 하는 특정 실행 인터페이스를 정의했습니다. 현재 접근 방식은 기존 스마트 계정과의 호환성을 유지하면서 복잡한 동작(배치, delegatecall, CREATE2)을 지원하기 위해 ERC-7579의 실행 모델을 채택했습니다.

## 보안 고려사항

### 권한 처리

애플리케이션은 권한 조건의 올바른 해석을 보장하고 무단 작업을 방지하기 위해 철저한 보안 감사가 필요합니다.

### 중요한 권한 검증 규칙

```
⚠️ 과거 위임이 미래 실행 권한을 보장한다고 가정하지 마세요
```

| 규칙 | 설명 |
|------|------|
| 만료 확인 | 위임은 만료될 수 있음 |
| 취소 확인 | 위임은 취소될 수 있음 |
| 상태 변경 | 상태 변경으로 무효화될 수 있음 |
| 항상 시뮬레이션 | 제출 전 항상 시뮬레이션 |
| 실패 처리 | 권한 재요청으로 실패를 우아하게 처리 |
| 재시도 로직 | 에스컬레이션 요청으로 재시도 로직 구현 |
| 무효화 대비 | 시뮬레이션과 실행 사이의 무효화에 대비 |

### 공격 벡터 및 완화

```solidity
// 재진입 방지
contract SecureDelegationManager {
    bool private _locked;

    modifier nonReentrant() {
        require(!_locked, "Reentrant call");
        _locked = true;
        _;
        _locked = false;
    }

    function redeemDelegations(...) external nonReentrant {
        // 실행 로직
    }
}

// 리플레이 방지
contract ReplayProtectedDelegation {
    mapping(bytes32 => bool) public usedDelegations;

    function validateDelegation(bytes32 hash) internal {
        require(!usedDelegations[hash], "Delegation already used");
        usedDelegations[hash] = true;
    }
}
```

## 하위 호환성

이 표준은 기존 스마트 계정 구현과 호환됩니다:

- **ERC-4337 계정**: `validateUserOp`을 통한 위임 검증
- **ERC-1271 계정**: `isValidSignature`를 통한 서명 검증
- **ERC-7579 계정**: 모듈식 실행 지원

## 사용 사례

### 구독 서비스

```solidity
// 월간 구독 위임
Delegation memory subscription = Delegation({
    delegate: SUBSCRIPTION_SERVICE,
    delegator: USER_WALLET,
    authority: keccak256("SUBSCRIPTION"),
    caveats: [
        Caveat({
            enforcer: tokenAllowanceEnforcer,
            terms: abi.encode(USDC, 100e6)  // 월 $100
        }),
        Caveat({
            enforcer: rateLimitEnforcer,
            terms: abi.encode(1, 30 days)   // 월 1회
        })
    ],
    salt: block.timestamp,
    signature: userSignature
});
```

### AI 에이전트 권한

```solidity
// AI 트레이딩 봇에 제한된 권한 부여
Delegation memory aiAgent = Delegation({
    delegate: AI_AGENT_ADDRESS,
    delegator: USER_WALLET,
    authority: keccak256("AI_TRADING"),
    caveats: [
        Caveat({
            enforcer: allowedTargetsEnforcer,
            terms: abi.encode([DEX_ROUTER, LENDING_PROTOCOL])
        }),
        Caveat({
            enforcer: maxValueEnforcer,
            terms: abi.encode(1 ether)  // 거래당 최대 1 ETH
        })
    ],
    salt: block.timestamp,
    signature: userSignature
});
```

### 게임 세션

```solidity
// 게임 세션 위임
Delegation memory gameSession = Delegation({
    delegate: GAME_SERVER,
    delegator: PLAYER_WALLET,
    authority: keccak256("GAME_SESSION"),
    caveats: [
        Caveat({
            enforcer: allowedContractsEnforcer,
            terms: abi.encode([GAME_CONTRACT, NFT_CONTRACT])
        }),
        Caveat({
            enforcer: expiryEnforcer,
            terms: abi.encode(block.timestamp + 2 hours)
        })
    ],
    salt: block.timestamp,
    signature: playerSignature
});
```

## 참조 구현

### 최소 예제

```solidity
// Example7710Manager.sol
contract Example7710Manager is ERC7710Manager {
    function redeemDelegations(
        bytes[] calldata _permissionContexts,
        bytes32[] calldata _modes,
        bytes[] calldata _executionCallData
    ) external override {
        require(
            _permissionContexts.length == _modes.length &&
            _modes.length == _executionCallData.length,
            "Length mismatch"
        );

        for (uint i = 0; i < _permissionContexts.length; i++) {
            _validateAndExecute(
                _permissionContexts[i],
                _modes[i],
                _executionCallData[i]
            );
        }
    }

    function _validateAndExecute(
        bytes calldata context,
        bytes32 mode,
        bytes calldata callData
    ) internal {
        Delegation memory delegation = abi.decode(context, (Delegation));

        // 서명 검증
        require(_validateSignature(delegation), "Invalid signature");

        // Caveat 실행
        for (uint i = 0; i < delegation.caveats.length; i++) {
            ICaveatEnforcer(delegation.caveats[i].enforcer).beforeHook(
                delegation.caveats[i].terms,
                "",
                mode,
                callData,
                keccak256(context),
                msg.sender,
                delegation.delegator
            );
        }

        // 위임자를 통해 실행
        ISmartAccount(delegation.delegator).execute(mode, callData);
    }
}
```

### 전체 구현

- [MetaMask Delegation Framework](https://github.com/MetaMask/delegation-framework)
  - EIP-712 검증
  - ERC-1271 지원
  - Caveat 시행
  - 배치 처리
  - 취소 관리

## 의존성

- EIP-1271: 서명 검증
- EIP-7579: 실행 동작 표준

## 참조

- [ERC-7710 공식 문서](https://eips.ethereum.org/EIPS/eip-7710)
- [ERC-7715 Permission Grant](https://eips.ethereum.org/EIPS/eip-7715)
- [MetaMask Delegation Framework](https://github.com/MetaMask/delegation-framework)
